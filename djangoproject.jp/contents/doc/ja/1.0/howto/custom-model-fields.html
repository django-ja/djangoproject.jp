<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>カスタムのモデルフィールド &mdash; Django v1.0 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.0',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="contents" title="Global table of contents" href="../contents.html" />
    <link rel="index" title="Global index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="top" title="Django v1.0 documentation" href="../index.html" />
    <link rel="up" title="HOWTO ガイド" href="index.html" />
    <link rel="next" title="テンプレートタグやフィルタを自作する" href="custom-template-tags.html" />
    <link rel="prev" title="アクションを自作する" href="custom-management-commands.html" />
  </head>
  <body>
  <div id="outdated-warning" class="doc-floating-warning" style="position: relative;">
    このドキュメントの Django のバージョンにはセキュリティ上の脆弱性があるため、すでにサポートが終了されています。新しいバージョンにアップグレードしてください！<a href="https://docs.djangoproject.com/ja/">最新の Django のバージョンのドキュメントはこちら</a>
  </div>
  <div id="custom-doc" class="yui-t6">
    <div id="hd">
      <h1><a href="../index.html">Django v1.0 documentation</a></h1>
      <div id="global-nav">
        <a title="Home page" href="../index.html">ホーム</a>  |
        <a title="Table of contents" href="../contents.html">目次</a>  |
        <a title="Global index" href="../genindex.html">索引</a>  |
        <a title="Search" href="../modindex.html">モジュール一覧</a>
      </div>
      <div class="nav">
    &laquo; <a href="custom-management-commands.html" title="アクションを自作する">前へ</a> 
     |
    <a href="index.html" title="HOWTO ガイド" accesskey="U">上へ</a>
   |
    <a href="custom-template-tags.html" title="テンプレートタグやフィルタを自作する">次へ</a> &raquo;</div>
    </div>
    
    <div id="bd">
      <div id="yui-main">
        <div class="yui-b">
          <div class="yui-g" id="howto-custom-model-fields">
            
  
  <div class="section" id="s-id1">
<span id="s-howto-custom-model-fields"></span><h1>カスタムのモデルフィールド<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">revision-up-to:</th><td class="field-body">8961 (1.0)</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<span class="title">Django 1.0 で新たに登場しました.</span> </div>
<div class="section" id="s-id2">
<span id="s-introduction"></span><h2>はじめに<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="../topics/db/models.html#topics-db-models"><em>モデルリファレンス</em></a> ドキュメントでは、
<a title="django.db.models.CharField" class="reference external" href="../ref/models/fields.html#django.db.models.CharField"><tt class="xref docutils literal"><span class="pre">CharField</span></tt></a> や
<a title="django.db.models.DateField" class="reference external" href="../ref/models/fields.html#django.db.models.DateField"><tt class="xref docutils literal"><span class="pre">DateField</span></tt></a> といった Django の標準のフィールドクラ
スの使用法について説明しています。ほとんどの用途には、これらの標準フィール
ドクラスだけで十分でしょう。とはいえ、現行の Django が自分の要求をうまく満
たしていない場合や、 Django が提供しているものと全く異なるフィールドを使い
たい場合もあるでしょう。</p>
<p>Django の組み込みフィールド型は、データベースのカラムとして利用できる全ての
データ型をサポートしているわけではなく、 <tt class="docutils literal"><span class="pre">VARCHAR</span></tt> や <tt class="docutils literal"><span class="pre">INTEGER</span></tt> のよう
な一般的な型しかサポートしていません。幾何多角形 (geographic polygon) 型や、
<a class="reference external" href="http://www.postgresql.org/docs/8.2/interactive/sql-createtype.html">PostgreSQL カスタム型</a> のようなユーザ定義型といった特異な型を扱うには、
<tt class="docutils literal"><span class="pre">Field</span></tt> 型のサブクラスを定義する必要があります。</p>
<p><tt class="docutils literal"><span class="pre">Field</span></tt> 型のサブクラス定義には、別の用途もあります。複雑な Python オブジェ
クトをシリアライズして、標準的なデータベースのカラム型に変換して保存したい
場合です。こうした場合にも、 <tt class="docutils literal"><span class="pre">Field</span></tt> のサブクラスを定義しておき、モデルで
使うと便利です。</p>
<div class="section" id="s-id3">
<span id="s-our-example-object"></span><h3>Our example object<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>カスタムフィールドを作成するには、ちょっと注意が必要です。説明についていけ
るように、このドキュメントでは一貫して一つの例題を扱うことにします。
ここでは、まず <a class="reference external" href="http://ja.wikipedia.org/wiki/コントラクトブリッジ">ブリッジ</a> の「手」を表す Python オブジェクトを考えましょう。
(ブリッジの遊び方をしらなくても、心配することはありません。知っておくべきな
のは、ブリッジは、 52 枚のカードを 4 人のプレイヤーで扱う遊びで、プレイヤー
は伝統的に <em>north</em>, <em>east</em>, <em>south</em>, <em>west</em> と呼ばれることだけです。)
<tt class="docutils literal"><span class="pre">Hand</span></tt> クラスは以下のように定義されています:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Hand</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">north</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">west</span><span class="p">):</span>
        <span class="c"># パラメタはカードのリスト (&#39;Ah&#39;, &#39;9s&#39;, など)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">north</span> <span class="o">=</span> <span class="n">north</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">east</span> <span class="o">=</span> <span class="n">east</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">south</span> <span class="o">=</span> <span class="n">south</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">west</span> <span class="o">=</span> <span class="n">west</span>

    <span class="c"># ... (他のメソッドはここでは省略します) ...</span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">Hand</span></tt> はただの普通の Python クラスで、 Django 固有の定義は一切していませ
ん。このクラスを、モデルで扱えるようにしましょう (モデルの <tt class="docutils literal"><span class="pre">hand</span></tt> という
属性に <tt class="docutils literal"><span class="pre">Hand</span></tt> のインスタンスが入るようにします):</p>
<div class="highlight"><pre><span class="n">example</span> <span class="o">=</span> <span class="n">MyModel</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">print</span> <span class="n">example</span><span class="o">.</span><span class="n">hand</span><span class="o">.</span><span class="n">north</span>

<span class="n">new_hand</span> <span class="o">=</span> <span class="n">Hand</span><span class="p">(</span><span class="n">north</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">west</span><span class="p">)</span>
<span class="n">example</span><span class="o">.</span><span class="n">hand</span> <span class="o">=</span> <span class="n">new_hand</span>
<span class="n">example</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
<p>上の例では、 <tt class="docutils literal"><span class="pre">hand</span></tt> 属性を、他の Python クラスと同様に代入や値参照に使っ
ています。このようなことができるトリックは、 Django に <tt class="docutils literal"><span class="pre">Hand</span></tt> オブジェク
トの保存やロードの方法を教えることで実現できます。</p>
<p>モデルから <tt class="docutils literal"><span class="pre">Hand</span></tt> クラスを扱うために、 <tt class="docutils literal"><span class="pre">Hand</span></tt> に手を加える必要は
<strong>全くありません</strong> 。その方が、例えば既存のクラスでソースコードに手を加えら
れないような場合にも、簡単にモデル上でサポートできるからです。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">単に、カスタムのデータベースカラム型を使って、文字列や浮動小数点型といっ
た標準の Python データを扱いたいという場合もあるでしょう。このケースも
<tt class="docutils literal"><span class="pre">Hand</span></tt> の例とほぼ同様で、違いは後で説明します。</p>
</div>
</div>
</div>
<div class="section" id="s-id6">
<span id="s-background-theory"></span><h2>基本的な考え方<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<div class="section" id="s-id7">
<span id="s-database-storage"></span><h3>データベースストレージ<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>モデルフィールドの役割とは、簡単に言えば、文字列、ブール型、 <tt class="docutils literal"><span class="pre">datetime</span></tt>
型、そして <tt class="docutils literal"><span class="pre">Hand</span></tt> のようなより複雑なデータ型の Python オブジェクトを
受け取って、データベースを操作するときに便利な形式に変換することです。
(シリアライザ用にも変換しますが、後で説明するように、一度データベース側の変
換ができるようになれば、シリアライザ用の変換はかなり簡単です)。</p>
<p>モデル内のフィールド値は、データベース上では何らかのカラムタイプに変換され
ねばなりません。データベースはバックエンド毎に固有の異なったカラム型を提供
しています。</p>
<p><tt class="docutils literal"><span class="pre">Hand</span></tt> の例の場合には、プレイヤーのカード情報を、予め決まった順番、
<em>north</em>, <em>east</em>, <em>south</em>, <em>west</em> の順番にくっつけて、 104 文字の文字列に変
換します。従って、 <tt class="docutils literal"><span class="pre">Hand</span></tt> オブジェクトはデータベースにテキスト型はキャラ
クタ型で保存できます。</p>
</div>
<div class="section" id="s-id8">
<span id="s-what-does-a-field-class-do"></span><h3>フィールドクラスの役割<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>Django のフィールド型 (このドキュメントで <em>フィールド</em> という場合には、基本
的に <a class="reference external" href="../ref/forms/fields.html#ref-forms-fields"><em>フォームフィールド</em></a> ではなくモデルフィールド
を指します) は、全て <tt class="xref docutils literal"><span class="pre">django.db.models.Field</span></tt> のサブクラスです。
Django がフィールドごとに記録する情報は、ほとんどのフィールドで共通で、名前、
ヘルプテキスト、バリデータのリスト、ユニークキーにするか、といったものです。
こうした情報の保存は``Field`` クラスで行います。 <tt class="docutils literal"><span class="pre">Field</span></tt> の動作については、
後で詳細に説明しますが、さしあたっては、全ては <tt class="docutils literal"><span class="pre">Field</span></tt> から継承していて、
その中からクラスの挙動の鍵になる部分をカスタマイズするのだと考えておけば十
分です。</p>
<p>Django のフィールドクラスは、モデルの属性値を保存するためのオブジェクトでは
ない、ということをよく理解しておいてください。モデルの属性値には、通常の
Python オブジェクトが入っています。モデル内でフィールドを定義すると、その
フィールドクラスは、モデルクラスの生成時に内部クラス <tt class="docutils literal"><span class="pre">Meta</span></tt> の中に保存さ
れます (詳しい動作の仕組みは、ここではあまり重要ではありません)。モデルイン
スタンスの属性値を作成したり、変更する時には、フィールドクラスは必要ないの
です。その代わり、フィールドクラスは、属性の値と、データベースに保存したり、
<a class="reference external" href="../topics/serialization.html#topics-serialization"><em>シリアライザ</em></a> に送信したりするための値との間の
変換機構を提供しています。</p>
<p>カスタムのフィールドクラスを定義する際には、上記のことを心に留めておいてく
ださい。 Django の <tt class="docutils literal"><span class="pre">Field</span></tt> サブクラスは、 Python オブジェクトとデータベー
スやシリアライザ向けの値との変換を色々な方法で実現するための機構を提供しま
す (例えば、データを保存するための変換と、照合に使うための変換には違いがあ
ります)。この仕組みがトリッキーに見えても、心配する必要はありません。以下の
例を読み進めていくうちにはっきり分かるでしょう。ただ、たいていの場合、カス
タムフィールドが必要な場面では、以下の二つのクラスを定義することになるとい
うことを覚えておいてください:</p>
<ul class="simple">
<li>一つ目は、ユーザが操作する Python オブジェクトです。このオブジェクト
はモデルの属性値として代入され、表示時に読み出されます。例でいうと
<tt class="docutils literal"><span class="pre">Hand</span></tt> クラスです。</li>
<li>もう一つは <tt class="docutils literal"><span class="pre">Field</span></tt> のサブクラスです。このクラスには、上のクラスと
永続ストレージとの間で相互変換を行うための処理が組み込まれています。</li>
</ul>
</div>
</div>
<div class="section" id="s-id9">
<span id="s-writing-a-field-subclass"></span><h2>フィールドのサブクラスを定義する<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p><tt class="xref docutils literal"><span class="pre">Field</span></tt> のサブクラスを定義するときには、まずは作り
たいフィールドが既存のフィールドクラスのどれに一番近いかを考えましょう。</p>
<p>既存の Django のフィールド型をサブクラス化すれば、作業が楽になるでしょうか？
もしそうでなければ、 <tt class="xref docutils literal"><span class="pre">Field</span></tt>  クラスをサブクラス化
します。</p>
<p>フィールドの初期化時には、 <tt class="xref docutils literal"><span class="pre">Field</span></tt>  クラス (または
親クラス) 共通の引数と、新たなフィールドクラス固有の引数を分離して、前者を
親クラスの <tt class="xref docutils literal"><span class="pre">__init__()</span></tt> に渡します。</p>
<p>このドキュメントの例題では、定義するフィールドを <tt class="docutils literal"><span class="pre">HandField</span></tt> と呼ぶことに
しましょう (フィールドを <tt class="docutils literal"><span class="pre">(何とか)Field</span></tt> と呼ぶようにしておけば、クラスが
<tt class="xref docutils literal"><span class="pre">Field</span></tt>  のサブクラスであるとすぐ分かるからです)。
<tt class="docutils literal"><span class="pre">HandField</span></tt> は既存のフィールドと似た部分はあまりないので、
<tt class="xref docutils literal"><span class="pre">Field</span></tt>  クラスから直接導出します:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>

<span class="k">class</span> <span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;max_length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">104</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">HandField</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">HandField</span></tt> は標準的なフィールドオプションのほとんどを指定できます。ただ
し、このフィールドは高々 52 枚のカードの値と種類だけを保存できればよいので、
合計 104 文字分の固定長にしておきます。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>多くの Django のモデルフィールドは、そのフィールドに関係のないオプショ
ンも引数に指定できます。例えば、
<tt class="xref docutils literal"><span class="pre">editable</span></tt> と
<tt class="xref docutils literal"><span class="pre">auto_now</span></tt> の両方を
<a title="django.db.models.DateField" class="reference external" href="../ref/models/fields.html#django.db.models.DateField"><tt class="xref docutils literal"><span class="pre">DateField</span></tt></a> に指定してもよく、
<a title="django.db.models.DateField" class="reference external" href="../ref/models/fields.html#django.db.models.DateField"><tt class="xref docutils literal"><span class="pre">DateField</span></tt></a> は
(<tt class="xref docutils literal"><span class="pre">auto_now</span></tt> を指定すると
<tt class="docutils literal"><span class="pre">editable=False</span></tt> なので) <tt class="xref docutils literal"><span class="pre">editable</span></tt> パ
ラメタを無視します。この場合、エラーは送出されません。</p>
<p class="last">このような挙動にしておくと、不要なオプションをいちいちチェックしなくて
よいので、フィールドクラスの定義が簡単になります。サブクラスでは、単に
全てのオプションを親クラスに渡しておけばよく、それ以上何もしなくてよい
のです。選べるオプションを厳しく制限してもよいですし、簡単にしたければ、
何でも指定できるようにしておけばよいのです。</p>
</div>
<p><tt class="xref docutils literal"><span class="pre">__init__()</span></tt> メソッドは、以下のパラメタを (列挙
順に) 取ります:</p>
<ul class="simple">
<li><tt class="xref docutils literal"><span class="pre">verbose_name</span></tt></li>
<li><tt class="xref docutils literal"><span class="pre">name</span></tt></li>
<li><tt class="xref docutils literal"><span class="pre">primary_key</span></tt></li>
<li><tt class="xref docutils literal"><span class="pre">max_length</span></tt></li>
<li><tt class="xref docutils literal"><span class="pre">unique</span></tt></li>
<li><tt class="xref docutils literal"><span class="pre">blank</span></tt></li>
<li><tt class="xref docutils literal"><span class="pre">null</span></tt></li>
<li><tt class="xref docutils literal"><span class="pre">db_index</span></tt></li>
<li><tt class="xref docutils literal"><span class="pre">core</span></tt></li>
<li><tt class="xref docutils literal"><span class="pre">rel</span></tt>: (<tt class="xref docutils literal"><span class="pre">ForeignKey</span></tt> のような)
リレーションに関するフィールドで使います。高度な用途でしか必要ありま
せん。</li>
<li><tt class="xref docutils literal"><span class="pre">default</span></tt></li>
<li><tt class="xref docutils literal"><span class="pre">editable</span></tt></li>
<li><tt class="xref docutils literal"><span class="pre">serialize</span></tt>: <tt class="xref docutils literal"><span class="pre">False</span></tt> の場合、モデルイ
ンスタンスを <a class="reference external" href="../topics/serialization.html#topics-serialization"><em>シリアライザ</em></a> に渡しても、
フィールドをシリアライズしません。デフォルトの値は <tt class="xref docutils literal"><span class="pre">True</span></tt> です。</li>
<li><tt class="xref docutils literal"><span class="pre">prepopulate_from</span></tt></li>
<li><tt class="xref docutils literal"><span class="pre">unique_for_date</span></tt></li>
<li><tt class="xref docutils literal"><span class="pre">unique_for_month</span></tt></li>
<li><tt class="xref docutils literal"><span class="pre">unique_for_year</span></tt></li>
<li><tt class="xref docutils literal"><span class="pre">validator_list</span></tt></li>
<li><tt class="xref docutils literal"><span class="pre">choices</span></tt></li>
<li><tt class="xref docutils literal"><span class="pre">help_text</span></tt></li>
<li><tt class="xref docutils literal"><span class="pre">db_column</span></tt></li>
<li><tt class="xref docutils literal"><span class="pre">db_tablespace</span></tt>: 現状は Oracle バックエ
ンドだけで使っています。インデクス生成に使います。通常、このオプショ
ンは無視できます。</li>
</ul>
<p>上のリストで解説のないオプションは、通常の Django のフィールドと同じ意味を
持っています。詳しくは <a class="reference external" href="../ref/models/fields.html#ref-models-fields"><em>モデルのドキュメント</em></a> を参
照してください。</p>
<div class="section" id="s-subfieldbase">
<span id="s-the-subfieldbase-metaclass"></span><h3><tt class="docutils literal"><span class="pre">SubfieldBase</span></tt> メタクラス<a class="headerlink" href="#subfieldbase" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#id2">はじめに</a> でも説明したように、フィールド型のサブクラスが必要な理由は主に
二つあります。一つはカスタムのデータベースカラム型を利用したい場合、もう一
つは複雑な Python のデータ型を扱いたい場合です。もちろん、二つを合わせて実
現するのも可能です。カスタムのデータベースカラム型を扱っているだけで、かつ
Python からモデルフィールドを扱うときのデータ型が、データベースバックエンド
から取り出したデータの型と一致している場合には、この節を気にする必要はあり
ません。</p>
<p><tt class="docutils literal"><span class="pre">Hand</span></tt> クラスのようにカスタムの Python 型を扱うフィールドを作成したい場合、
Django がモデルのインスタンスを生成して、フィールドの属性値をデータベースに
保存する時に、フィールドの値を適切な Python オブジェクトに変換する必要が
あります。この処理のからくりはやや複雑ですが、フィールドクラスを定義すると
きに書かねばならないコードはいたって単純で、特殊なメタクラスを使ってサブク
ラスを作成するだけです:</p>
<pre>class HandField(models.Field):
    __metaclass__ = models.SubfieldBase

    def __init__(self, *args, **kwargs):
        # ...</pre>
<p>こうしておけば、属性値を初期化する際に、自動的に <a title="to_python" class="reference internal" href="#to_python"><tt class="xref docutils literal"><span class="pre">to_python()</span></tt></a> メソッド
が呼び出されるようになります。 <a title="to_python" class="reference internal" href="#to_python"><tt class="xref docutils literal"><span class="pre">to_python()</span></tt></a> メソッドについては後で解説
します。</p>
</div>
<div class="section" id="s-id10">
<span id="s-useful-methods"></span><h3>便利なメソッド<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p><tt class="xref docutils literal"><span class="pre">Field</span></tt>  のサブクラスを作成して、
<tt class="docutils literal"><span class="pre">__metaclass__</span></tt> をセットアップしたら、次はフィールドの挙動に応じて標準メ
ソッドをいくつかオーバライドします。以下のメソッドは上からよく使う順に挙げ
ています。</p>
<div class="section" id="s-id11">
<h4>データベース型のカスタマイズ<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="db_type">
<!--[db_type]--><tt class="descname">db_type</tt>(<em>self</em>)<a class="headerlink" href="#db_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><a class="reference external" href="../ref/settings.html#setting-DATABASE_ENGINE"><tt class="xref docutils literal"><span class="pre">DATABASE_ENGINE</span></tt></a> 設定に指定されているデータベースで、フィールドの
データを保存するために使うカラム型を返します。</p>
<p>例えば、 PostgreSQL 固有のカスタム型 <tt class="docutils literal"><span class="pre">mytype</span></tt> を作成したとしましょう。
Django からこの型を使うには、以下のように <tt class="xref docutils literal"><span class="pre">Field</span></tt>
をサブクラス化して、 <a title="db_type" class="reference internal" href="#db_type"><tt class="xref docutils literal"><span class="pre">db_type()</span></tt></a> メソッドを実装します:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>

<span class="k">class</span> <span class="nc">MytypeField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">db_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;mytype&#39;</span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">MytypeField</span></tt> を定義したら、他のフィールド型と同じようにモデルで利用でき
ます:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Person</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">80</span><span class="p">)</span>
    <span class="n">gender</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">something_else</span> <span class="o">=</span> <span class="n">MytypeField</span><span class="p">()</span>
</pre></div>
<p>データベースに依存しないアプリケーションを構築したいなら、データベース毎
のカラム型の違いに注意しておかねばなりません。例えば、 PostgreSQL では日付
や時間に関するカラム型は <tt class="docutils literal"><span class="pre">timestamp</span></tt> 型ですが、 MySQL では <tt class="docutils literal"><span class="pre">datetime</span></tt>
型です。この違いを <a title="db_type" class="reference internal" href="#db_type"><tt class="xref docutils literal"><span class="pre">db_type()</span></tt></a> メソッドの中で吸収するには、Djangoの
<tt class="docutils literal"><span class="pre">settings</span></tt> モジュールを import しておいて、以下のように
<a class="reference external" href="../ref/settings.html#setting-DATABASE_ENGINE"><tt class="xref docutils literal"><span class="pre">DATABASE_ENGINE</span></tt></a> 設定をチェックします:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">MyDateField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">db_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">django.conf</span> <span class="kn">import</span> <span class="n">settings</span>
        <span class="k">if</span> <span class="n">settings</span><span class="o">.</span><span class="n">DATABASE_ENGINE</span> <span class="o">==</span> <span class="s">&#39;mysql&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&#39;datetime&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&#39;timestamp&#39;</span>
</pre></div>
<p><a title="db_type" class="reference internal" href="#db_type"><tt class="xref docutils literal"><span class="pre">db_type()</span></tt></a> メソッドは、Django がアプリケーションのテーブルを生成する
ための <tt class="docutils literal"><span class="pre">CREATE</span> <span class="pre">TABLE`</span></tt> 文を構築する瞬間、すなわち最初にテーブルを生成する
瞬間しか呼び出されません。それ以外の場合に呼び出されることはないので、上記
の <a class="reference external" href="../ref/settings.html#setting-DATABASE_ENGINE"><tt class="xref docutils literal"><span class="pre">DATABASE_ENGINE</span></tt></a> をチェックする例のような多少ややこしいコード
を書いてもさして問題ではありません。</p>
<p>カラムのデータ型にはパラメタを取るものがあります。例えば <tt class="docutils literal"><span class="pre">CHAR(25)</span></tt> は、
<tt class="docutils literal"><span class="pre">25</span></tt> がカラムの最大長を表しています。こうした場合には、 <a title="db_type" class="reference internal" href="#db_type"><tt class="xref docutils literal"><span class="pre">db_type()</span></tt></a>
メソッド内でハードコードしておくよりも、モデル内でパラメタを指定して使える
方が柔軟性を高められます。例えば、以下に示すような <tt class="docutils literal"><span class="pre">CharMaxlength25Field</span></tt>
はあまり便利ではありません:</p>
<div class="highlight"><pre><span class="c"># パラメタをハードコードしているおバカな例</span>
<span class="k">class</span> <span class="nc">CharMaxlength25Field</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">db_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;char(25)&#39;</span>

<span class="c"># モデル内での使い方</span>
<span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c"># ...</span>
    <span class="n">my_field</span> <span class="o">=</span> <span class="n">CharMaxlength25Field</span><span class="p">()</span>
</pre></div>
<p>実行時、すなわちフィールドクラスをインスタンス化する時にパラメタを指定でき
た方がよいでしょう。パラメタを指定できるようにするには、以下のように
<tt class="xref docutils literal"><span class="pre">django.db.models.Field.__init__()</span></tt> を実装します:</p>
<div class="highlight"><pre><span class="c"># より柔軟性のある例</span>
<span class="k">class</span> <span class="nc">BetterCharField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxlength</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span> <span class="o">=</span> <span class="n">max_length</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BetterCharField</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">db_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;char(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span>

<span class="c"># モデル内での使い方</span>
<span class="k">class</span> <span class="nc">MyModel</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c"># ...</span>
    <span class="n">my_field</span> <span class="o">=</span> <span class="n">BetterCharField</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>
</pre></div>
<p>最後に、カラムの操作に非常に複雑な SQL が必要な場合には、 <a title="db_type" class="reference internal" href="#db_type"><tt class="xref docutils literal"><span class="pre">db_type()</span></tt></a>
に <tt class="xref docutils literal"><span class="pre">None</span></tt> を返させましょう。そうすれば、 Django の SQL 生成コードはこの
フィールドの処理をスキップします。もちろん、その場合には、何らかの方法で正
しいテーブルに正しいカラムを生成する必要があります。</p>
</div>
<div class="section" id="s-python">
<span id="s-converting-database-values-to-python-objects"></span><h4>データベース上の値を Python オブジェクトに変換する<a class="headerlink" href="#python" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="to_python">
<!--[to_python]--><tt class="descname">to_python</tt>(<em>self</em>, <em>value</em>)<a class="headerlink" href="#to_python" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>データベース (またはシリアライザ) の返す値を Python オブジェクトに変換しま
す。</p>
<p>デフォルトの実装では、単に <tt class="docutils literal"><span class="pre">value</span></tt> を返します。通常は、データベースバック
エンドは正しい形式 (Python 文字列型など) でデータを返すからです。</p>
<p>カスタムのフィールドクラスで、文字列や日時、整数や浮動小数点型といったデー
タ型よりも複雑なデータ構造を扱いたい場合、このメソッドをオーバライドする必
要があります。一般的な規則として、このメソッドは以下の引数をきちんと扱えね
ばなりません:</p>
<ul class="simple">
<li>正しい型のインスタンス (このドキュメントの例では <tt class="docutils literal"><span class="pre">Hand</span></tt> オブジェク
ト)</li>
<li>文字列 (デシリアライザなどが返す値)</li>
<li>このフィールドのカラムタイプに対して、データベースバックエンドが返す
値</li>
</ul>
<p><tt class="docutils literal"><span class="pre">HandField</span></tt> クラスでは、データを VARCHAR フィールドで保存しているので、
<a title="to_python" class="reference internal" href="#to_python"><tt class="xref docutils literal"><span class="pre">to_python()</span></tt></a> は文字列と <tt class="docutils literal"><span class="pre">Hand</span></tt> インスタンスの両方を扱えねばなりません:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">re</span>

<span class="k">class</span> <span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="c"># ...</span>

    <span class="k">def</span> <span class="nf">to_python</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Hand</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>

        <span class="c"># The string case.</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;.{26}&#39;</span><span class="p">)</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;..&#39;</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">p2</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p1</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">value</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">Hand</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>
<p>このメソッドは常に <tt class="docutils literal"><span class="pre">Hand</span></tt> インスタンスを返していることに注意してください。
<a title="to_python" class="reference internal" href="#to_python"><tt class="xref docutils literal"><span class="pre">to_python()</span></tt></a> は、モデルの属性値として保存したい Python オブジェクト型を
返します。</p>
<dl class="docutils">
<dt><strong>忘れないで！:</strong> カスタムフィールドに対して <a title="to_python" class="reference internal" href="#to_python"><tt class="xref docutils literal"><span class="pre">to_python()</span></tt></a> を呼び出した</dt>
<dd>ければ、上で述べた <a class="reference internal" href="#subfieldbase">SubfieldBase メタクラス</a> を使わねばなりません。メタ
クラスを使わないと、 <a title="to_python" class="reference internal" href="#to_python"><tt class="xref docutils literal"><span class="pre">to_python()</span></tt></a> は自動的に呼び出されません。</dd>
</dl>
</div>
<div class="section" id="s-id12">
<span id="s-converting-python-objects-to-database-values"></span><h4>Python オブジェクトをデータベース保存用の値に変換する<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="get_db_prep_value">
<!--[get_db_prep_value]--><tt class="descname">get_db_prep_value</tt>(<em>self</em>, <em>value</em>)<a class="headerlink" href="#get_db_prep_value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><a title="to_python" class="reference internal" href="#to_python"><tt class="xref docutils literal"><span class="pre">to_python()</span></tt></a> の逆のメソッドで、データベースバックエンドを扱うときに呼
び出されます。 <tt class="docutils literal"><span class="pre">value</span></tt> パラメタは、モデルの現在の属性値です (このような設
計になっているのは、個々のフィールドが、自身を組み込んでいるモデルに対する
参照を持っていないため、フィールドが自分でモデルインスタンスから値を取り出
せないからです)。 このメソッドは、データベースバックエンドのクエリパラメタ
として使えるようにデータをフォーマットして返さねばなりません。</p>
<p>例を示します:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="c"># ...</span>

    <span class="k">def</span> <span class="nf">get_db_prep_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">north</span><span class="p">,</span>
                <span class="n">value</span><span class="o">.</span><span class="n">east</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">south</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">west</span><span class="p">)])</span>
</pre></div>
<dl class="method">
<dt id="get_db_prep_save">
<!--[get_db_prep_save]--><tt class="descname">get_db_prep_save</tt>(<em>self</em>, <em>value</em>)<a class="headerlink" href="#get_db_prep_save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>前述のメソッドと同じですが、フィールドの値をデータベースに <em>保存</em> せねばな
らないときに呼び出されます。デフォルトの実装では単に <tt class="docutils literal"><span class="pre">get_db_prep_value</span></tt>
を呼び出しています。従って、データベースにデータを保存するときに、
(<tt class="docutils literal"><span class="pre">get_db_prep_value</span></tt> で実装している) 通常のクエリパラメタと違うものを使わ
ねばならないような特殊な状況を除き、このメソッドを実装する必要はありません。</p>
</div>
<div class="section" id="s-id13">
<span id="s-preprocessing-values-before-saving"></span><h4>保存前に値に前処理をほどこす<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="pre_save">
<!--[pre_save]--><tt class="descname">pre_save</tt>(<em>self</em>, <em>model_instance</em>, <em>add</em>)<a class="headerlink" href="#pre_save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>このメソッドは、 <a title="get_db_prep_save" class="reference internal" href="#get_db_prep_save"><tt class="xref docutils literal"><span class="pre">get_db_prep_save()</span></tt></a> の直前に呼び出され、このフィール
ドの <tt class="docutils literal"><span class="pre">model_instance</span></tt> での適切な値を生成して返さねばなりません。属性の名
前は  <tt class="docutils literal"><span class="pre">self.attrname</span></tt> で参照できます (この値はフィールドのインスタンス化
時に設定されます)。モデルインスタンスをデータベースに初めて保存しようとして
いる場合、 <tt class="docutils literal"><span class="pre">add</span></tt> パラメタの値は <tt class="xref docutils literal"><span class="pre">True</span></tt> です。それ以外の値は <tt class="xref docutils literal"><span class="pre">False</span></tt>
です。</p>
<p>このメソッドをオーバライドする必要があるのは、フィールドの値を、保存の直前
に前処理したい場合だけです。例えば、 Django の
<a title="django.db.models.DateTimeField" class="reference external" href="../ref/models/fields.html#django.db.models.DateTimeField"><tt class="xref docutils literal"><span class="pre">DateTimeField</span></tt></a> は、
<tt class="xref docutils literal"><span class="pre">auto_now</span></tt> や
<tt class="xref docutils literal"><span class="pre">auto_now_add</span></tt> で生成された場合、このメソッド
を使って正しい値をセットします。</p>
<p>このメソッドをオーバライドする場合、最後に属性の値を返さねばなりません。
また、フィールドの値を変更した場合、モデル上の対応する値も更新して、モデル
インスタンスを参照しているコードが正しい値を読み出せるようにせねばなりませ
ん。</p>
</div>
<div class="section" id="s-sql">
<span id="s-preparing-values-for-use-in-database-lookups"></span><h4>データベース照合時のパラメタを SQL 用に変換する<a class="headerlink" href="#sql" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="get_db_prep_lookup">
<!--[get_db_prep_lookup]--><tt class="descname">get_db_prep_lookup</tt>(<em>self</em>, <em>lookup_type</em>, <em>value</em>)<a class="headerlink" href="#get_db_prep_lookup" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>データベース上で照合を行う時 (<tt class="docutils literal"><span class="pre">WHERE</span></tt> 制約付きで SQL を発行する時) にデー
タベースに渡す値を前処理します。 <tt class="docutils literal"><span class="pre">lookup_type</span></tt> は、 Django のフィルタ照合
条件である <tt class="docutils literal"><span class="pre">exact</span></tt>, <tt class="docutils literal"><span class="pre">iexact</span></tt>, <tt class="docutils literal"><span class="pre">contains</span></tt>, <tt class="docutils literal"><span class="pre">icontains</span></tt>, <tt class="docutils literal"><span class="pre">gt</span></tt>,
<tt class="docutils literal"><span class="pre">gte</span></tt>, <tt class="docutils literal"><span class="pre">lt</span></tt>, <tt class="docutils literal"><span class="pre">lte</span></tt>, <tt class="docutils literal"><span class="pre">in</span></tt>, <tt class="docutils literal"><span class="pre">startswith</span></tt>, <tt class="docutils literal"><span class="pre">istartswith</span></tt>,
<tt class="docutils literal"><span class="pre">endswith</span></tt>, <tt class="docutils literal"><span class="pre">iendswith</span></tt>, <tt class="docutils literal"><span class="pre">range</span></tt>, <tt class="docutils literal"><span class="pre">year</span></tt>, <tt class="docutils literal"><span class="pre">month</span></tt>, <tt class="docutils literal"><span class="pre">day</span></tt>,
<tt class="docutils literal"><span class="pre">isnull</span></tt>, <tt class="docutils literal"><span class="pre">search</span></tt>, <tt class="docutils literal"><span class="pre">regex</span></tt>, <tt class="docutils literal"><span class="pre">iregex</span></tt> のいずれかの値を取ります。</p>
<p>このメソッドをオーバライドする場合、 <tt class="docutils literal"><span class="pre">lookup_type</span></tt> に指定される全ての照合
条件に対応せねばなりません。また、 <tt class="docutils literal"><span class="pre">value</span></tt> が正しい値でない場合 (単一のオ
ブジェクトが指定されるべきところにリストが指定された場合など) には
<tt class="docutils literal"><span class="pre">ValueError</span></tt> を、フィールドが指定した照合に対応していない場合には
<tt class="docutils literal"><span class="pre">TypeError</span></tt> を送出せねばなりません。たいていのフィールドでは、特別な扱い
の必要な照合タイプだけを処理して、残りは親クラスの
<a title="get_db_prep_lookup" class="reference internal" href="#get_db_prep_lookup"><tt class="xref docutils literal"><span class="pre">get_db_prep_lookup()</span></tt></a> メソッドに委ねればよいでしょう。</p>
<p><a title="get_db_prep_save" class="reference internal" href="#get_db_prep_save"><tt class="xref docutils literal"><span class="pre">get_db_prep_save()</span></tt></a> を定義するようなケースでは、通常
<a title="get_db_prep_lookup" class="reference internal" href="#get_db_prep_lookup"><tt class="xref docutils literal"><span class="pre">get_db_prep_lookup()</span></tt></a> も定義する必要があります。定義しなければ、
<tt class="docutils literal"><span class="pre">exact</span></tt>, <tt class="docutils literal"><span class="pre">gt</span></tt>, <tt class="docutils literal"><span class="pre">gte</span></tt>, <tt class="docutils literal"><span class="pre">lt</span></tt>, <tt class="docutils literal"><span class="pre">lte</span></tt>, <tt class="docutils literal"><span class="pre">in</span></tt>, <tt class="docutils literal"><span class="pre">range</span></tt> の照合時には
デフォルトの実装に従って、 <a title="get_db_prep_value" class="reference internal" href="#get_db_prep_value"><tt class="xref docutils literal"><span class="pre">get_db_prep_value()</span></tt></a> が呼び出されます。</p>
<p>また、カスタムのフィールド型でサポートする照合タイプを制限したい場合にも、
このメソッドを定義する必要があるでしょう。</p>
<p><tt class="docutils literal"><span class="pre">range</span></tt> や <tt class="docutils literal"><span class="pre">in</span></tt> を使った照合を行う場合、 <a title="get_db_prep_lookup" class="reference internal" href="#get_db_prep_lookup"><tt class="xref docutils literal"><span class="pre">get_db_prep_lookup()</span></tt></a> は
引数として (適切な型の) オブジェクトのリストを受け取り、データベースに渡せ
るなにがしか適切な型のオブジェクトからなるリストに変換せねばなりません。
大抵の場合は <a title="get_db_prep_save" class="reference internal" href="#get_db_prep_save"><tt class="xref docutils literal"><span class="pre">get_db_prep_save()</span></tt></a> を使い回したり、別のメソッドに共通の
処理を括り出しておけます。</p>
<p>例えば、以下のコードでは <a title="get_db_prep_lookup" class="reference internal" href="#get_db_prep_lookup"><tt class="xref docutils literal"><span class="pre">get_db_prep_lookup()</span></tt></a> を実装して、照合タイプ
を <tt class="docutils literal"><span class="pre">exact</span></tt> と <tt class="docutils literal"><span class="pre">in</span></tt> に制限しています:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="c"># ...</span>

    <span class="k">def</span> <span class="nf">get_db_prep_lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lookup_type</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c"># &#39;exact&#39; および &#39;in&#39; だけを扱います。それ以外はエラーにします。</span>
        <span class="k">if</span> <span class="n">lookup_type</span> <span class="o">==</span> <span class="s">&#39;exact&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_db_prep_value</span><span class="p">(</span><span class="n">value</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">lookup_type</span> <span class="o">==</span> <span class="s">&#39;in&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_db_prep_value</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Lookup type </span><span class="si">%r</span><span class="s"> not supported.&#39;</span> <span class="o">%</span> <span class="n">lookup_type</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="s-id14">
<span id="s-specifying-the-form-field-for-a-model-field"></span><h4>モデルフィールドに対応したフォームフィールドを指定する<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="formfield">
<!--[formfield]--><tt class="descname">formfield</tt>(<em>self</em>, <em>form_class=forms.CharField</em>, <em>**kwargs</em>)<a class="headerlink" href="#formfield" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>このフィールドをモデルに組み込んで、フォームで表示したときに使うデフォルト
のフォームフィールドを返します。このメソッドは、
<tt class="xref docutils literal"><span class="pre">ModelForm</span></tt> ヘルパから呼び出されます。</p>
<p><tt class="docutils literal"><span class="pre">kwargs</span></tt> 辞書の内容は、全てフォームフィールドの
<tt class="xref docutils literal"><span class="pre">Field__init__()</span></tt> メソッドに渡されます。通常、このメソッ
ドの定義では、適切な <tt class="docutils literal"><span class="pre">form_class</span></tt> 引数のデフォルト値を設定して、それ以降
の処理を親クラスに移譲しているだけです。フォームフィールドを定義する場合、
カスタムのフォームフィールド (や、フォームウィジェット) を書く必要があるか
もしれません。カスタムのフォームフィールドについては
<a class="reference external" href="../topics/forms/index.html#topics-forms-index"><em>forms のドキュメント</em></a> を参照してください。また、
カスタムウィジェットは <a title="特定の国や文化で有用な Django コードのコレクションです。" class="reference external" href="../ref/contrib/localflavor.html"><tt class="xref docutils literal"><span class="pre">django.contrib.localflavor</span></tt></a> のコードを参照する
とよいでしょう。</p>
<p>これまでの例に合わせて書くと、 <a title="formfield" class="reference internal" href="#formfield"><tt class="xref docutils literal"><span class="pre">formfield()</span></tt></a> メソッドは以下のように書け
ます:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="c"># ...</span>

    <span class="k">def</span> <span class="nf">formfield</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c"># メソッドの呼び出し側がデフォルトをオーバライド</span>
        <span class="c"># できるようにするための標準的な書き方</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;form_class&#39;</span><span class="p">:</span> <span class="n">MyFormField</span><span class="p">}</span>
        <span class="n">defaults</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">HandField</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">formfield</span><span class="p">(</span><span class="o">**</span><span class="n">defaults</span><span class="p">)</span>
</pre></div>
<p>上の例では、 <tt class="docutils literal"><span class="pre">MyFormField</span></tt> フィールドクラスを import しているのが前提です
(そして、 <tt class="docutils literal"><span class="pre">MyFormField</span></tt> でデフォルトのウィジェットを定義しています)。カス
タムのフォームフィールドの定義方法は、このドキュメントでは扱いません。</p>
</div>
<div class="section" id="s-id16">
<span id="s-emulating-built-in-field-types"></span><h4>組み込みのフィールド型をエミュレートする<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="get_internal_type">
<!--[get_internal_type]--><tt class="descname">get_internal_type</tt>(<em>self</em>)<a class="headerlink" href="#get_internal_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>データベースレベルでエミュレーションしているフィールド型の名前を返すメソッ
ドです。このメソッドは、簡単な方法でフィールド型を定義する際に、データベー
スのカラム型を決定するために使われます。</p>
<p><a title="db_type" class="reference internal" href="#db_type"><tt class="xref docutils literal"><span class="pre">db_type()</span></tt></a> メソッドを定義していれば、 <a title="get_internal_type" class="reference internal" href="#get_internal_type"><tt class="xref docutils literal"><span class="pre">get_internal_type()</span></tt></a> を気に
する必要はありません。このメソッドは、ほとんど使われません。ただし、フィー
ルド型のデータベースストレージが、他のフィールドと同じような型である場合、
このメソッドを定義しておくと、他のフィールドのロジックを使ってカラムを生成
させられます。</p>
<p>例を示します:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="c"># ...</span>

    <span class="k">def</span> <span class="nf">get_internal_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;CharField&#39;</span>
</pre></div>
<p>どのデータベースバックエンドを使っているかに関わらず、上のように定義してお
くと、 <tt class="docutils literal"><span class="pre">syncdb</span></tt> などの SQL 関係のコマンドを実行した時に、文字列を保存す
るための正しいカラム型を生成します。</p>
<p><a title="get_internal_type" class="reference internal" href="#get_internal_type"><tt class="xref docutils literal"><span class="pre">get_internal_type()</span></tt></a> が、 Django 上でもデータベースバックエンドでも対
応しない型を示す文字列を返した場合、すなわち、
<tt class="docutils literal"><span class="pre">django.db.backends.&lt;db_name&gt;.creation.DATA_TYPES</span></tt> に存在しない文字列を返
した場合、シリアライザはこの文字列を使いますが、デフォルトの
<a title="db_type" class="reference internal" href="#db_type"><tt class="xref docutils literal"><span class="pre">db_type()</span></tt></a> 実装は <tt class="xref docutils literal"><span class="pre">None</span></tt> を返します。なぜこのような挙動が有用なのか
は、 <a title="db_type" class="reference internal" href="#db_type"><tt class="xref docutils literal"><span class="pre">db_type()</span></tt></a> のドキュメントを読んでください。シリアライザに、フィー
ルドの型名として文字列を指定しておくと、 Django の外の何らかの場面でシリア
ライザの出力を扱うときに便利だからです。</p>
</div>
<div class="section" id="s-id17">
<span id="s-converting-field-data-for-serialization"></span><h4>シリアライゼーション用にフィールドデータを変換する<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h4>
<dl class="method">
<dt id="value_to_string">
<!--[value_to_string]--><tt class="descname">value_to_string</tt>(<em>self</em>, <em>obj</em>)<a class="headerlink" href="#value_to_string" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>このメソッドは、シリアライザがフィールドの値を出力する際に文字列に変換する
ために使います。シリアライズデータを生成するには、
<tt class="xref docutils literal"><span class="pre">Field._get_val_from_obj(obj)()</span></tt> を呼び出すとよいでしょう。例えば、例え
ば、 <tt class="docutils literal"><span class="pre">HandField</span></tt> はデータストレージに文字列を使っているので、既存の変換コー
ドを再利用できます:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">HandField</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Field</span><span class="p">):</span>
    <span class="c"># ...</span>

    <span class="k">def</span> <span class="nf">value_to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_val_from_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_db_prep_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="s-id18">
<span id="s-some-general-advice"></span><h3>一般的なアドバイス<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<p>カスタムフィールドの定義は、とりわけ Python 型とデータベース、そしてシリア
ライゼーション形式との間で複雑な変換を行う場合には、トリッキーな処理になり
がちです。よりスムーズにフィールドを定義するためのアドバイスを、以下に示し
ます:</p>
<ol class="arabic simple">
<li>既存のフィールド型定義 (<tt class="docutils literal"><span class="pre">django/db/models/fields/__init__.py</span></tt>
にあります) を見て、インスピレーションを得ましょう。全く何もない状態
からスクラッチでフィールドを定義するのではなく、自分の実現したいこと
に近い処理を行っているフィールド型を探して、それをちょっとだけ拡張す
るようにしましょう。</li>
<li>フィールドとしてラップしたいクラスに、 <tt class="xref docutils literal"><span class="pre">__str__()</span></tt> や
<tt class="xref docutils literal"><span class="pre">__unicode__()</span></tt> メソッドを定義しましょう。フィールドの処理におけ
るデフォルトの動作として、ラップしているクラスのインスタンスに対して
<tt class="xref docutils literal"><span class="pre">force_unicode()</span></tt> を呼び出すような処理が
たくさんあります。 (このドキュメントの例では、 <tt class="docutils literal"><span class="pre">value</span></tt> は <tt class="docutils literal"><span class="pre">Hand</span></tt>
のインスタンスであり、 <tt class="docutils literal"><span class="pre">HandField</span></tt> のインスタンスではないので)
<tt class="xref docutils literal"><span class="pre">__unicode__()</span></tt> メソッドを定義しておき、 Python オブジェクトが自
動的に文字列形式に変換されるようにしておけば、作業を大幅に減らせます。</li>
</ol>
</div>
</div>
<div class="section" id="s-filefield">
<h2><tt class="docutils literal"><span class="pre">FileField</span></tt> のサブクラスを定義する<a class="headerlink" href="#filefield" title="Permalink to this headline">¶</a></h2>
<p>上に挙げたメソッドに加えて、ファイルを扱うフィールドを定義するときには、い
くつか必要な条件があります。データベースストレージの操作やデータの取得など、
フィールド定義に必要なメカニズムのほとんどは <tt class="docutils literal"><span class="pre">FileField</span></tt> で定義しています
が、特定のタイプのファイルをサポートするための処理はサブクラスに委ねていま
す。</p>
<p>Django はファイルのコンテンツや操作をプロキシする <tt class="docutils literal"><span class="pre">File</span></tt> クラスを提供して
います。このクラスはサブクラス化でき、ファイルのアクセス方法やメソッドをカ
スタマイズできます。 <tt class="docutils literal"><span class="pre">File</span></tt> クラスは <tt class="docutils literal"><span class="pre">django.db.models.fields.files</span></tt> で
定義されており、デフォルトの動作は <a class="reference external" href="../ref/files/file.html#ref-files-file"><em>ファイルクラスのドキュメント</em></a> で解説しています。</p>
<p><tt class="docutils literal"><span class="pre">File</span></tt> のサブクラスを作ったら、 <tt class="docutils literal"><span class="pre">FileField</span></tt> サブクラスの <tt class="docutils literal"><span class="pre">attr_class</span></tt>
に指定して、 <tt class="docutils literal"><span class="pre">FileField</span></tt> サブクラスに指定のファイルクラスを使うよう指示し
てください。</p>
<div class="section" id="s-id19">
<h3>アドバイス<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<p>上に挙げた説明に加えて、カスタムフィールドのコードの効率や可読性を挙げるた
めのガイドラインをいくつか示しておきます。</p>
<ol class="arabic simple">
<li>Django の <tt class="docutils literal"><span class="pre">ImageField</span></tt> (<tt class="docutils literal"><span class="pre">django/db/models/fields/files.py</span></tt>) は、
<tt class="docutils literal"><span class="pre">FileField</span></tt> をサブクラス化して特定のファイルタイプをサポートしてい
る素晴らしい例題です。このクラスでは、上に述べたテクニックを余すとこ
ろ無く使っています。</li>
<li>可能な限り、ファイルの属性をキャッシュしましょう。ファイルは遠隔のス
トレージシステム上にあるので、ファイルデータの取得には時間もお金もか
かります。しかも、常に必要なわけではありません。一度ファイルを取得し
て、コンテンツに関するデータを収集したら、データ可能な限りキャッシュ
して、以後のアクセスでファイルを再取得する回数を減らしましょう。</li>
</ol>
</div>
</div>
</div>


          </div>         
        </div>
      </div>
      
        
          <div class="yui-b" id="sidebar">
            
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3>Table Of Contents</h3>
            <ul>
<li><a class="reference external" href="">カスタムのモデルフィールド</a><ul>
<li><a class="reference external" href="#id2">はじめに</a><ul>
<li><a class="reference external" href="#id3">Our example object</a></li>
</ul>
</li>
<li><a class="reference external" href="#id6">基本的な考え方</a><ul>
<li><a class="reference external" href="#id7">データベースストレージ</a></li>
<li><a class="reference external" href="#id8">フィールドクラスの役割</a></li>
</ul>
</li>
<li><a class="reference external" href="#id9">フィールドのサブクラスを定義する</a><ul>
<li><a class="reference external" href="#subfieldbase"><tt class="docutils literal"><span class="pre">SubfieldBase</span></tt> メタクラス</a></li>
<li><a class="reference external" href="#id10">便利なメソッド</a><ul>
<li><a class="reference external" href="#id11">データベース型のカスタマイズ</a></li>
<li><a class="reference external" href="#python">データベース上の値を Python オブジェクトに変換する</a></li>
<li><a class="reference external" href="#id12">Python オブジェクトをデータベース保存用の値に変換する</a></li>
<li><a class="reference external" href="#id13">保存前に値に前処理をほどこす</a></li>
<li><a class="reference external" href="#sql">データベース照合時のパラメタを SQL 用に変換する</a></li>
<li><a class="reference external" href="#id14">モデルフィールドに対応したフォームフィールドを指定する</a></li>
<li><a class="reference external" href="#id16">組み込みのフィールド型をエミュレートする</a></li>
<li><a class="reference external" href="#id17">シリアライゼーション用にフィールドデータを変換する</a></li>
</ul>
</li>
<li><a class="reference external" href="#id18">一般的なアドバイス</a></li>
</ul>
</li>
<li><a class="reference external" href="#filefield"><tt class="docutils literal"><span class="pre">FileField</span></tt> のサブクラスを定義する</a><ul>
<li><a class="reference external" href="#id19">アドバイス</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h3>前後のページ</h3>
  <ul>
    
      <li>前: <a href="custom-management-commands.html">アクションを自作する</a></li>
    
    
      <li>次: <a href="custom-template-tags.html">テンプレートタグやフィルタを自作する</a></li>
    
  </ul>
  <h3>現在のページ:</h3>
  <ul>
      <li>
        <a href="../index.html">Django v1.0 documentation</a>
        
          <ul><li><a href="index.html">HOWTO ガイド</a>
        
        <ul><li>カスタムのモデルフィールド</li></ul>
        </li></ul>
      </li>
  </ul>  

            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/howto/custom-model-fields.txt">Show Source</a></li>
            </ul>
            <h3>Quick search</h3>
            <form class="search" action="../search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
      </div>
              <h3>Last update:</h3>
              <p class="topless">Aug 31, 2012</p>
          </div> 
        
      
    </div>
    
    <div id="ft">
      <div class="nav">
    &laquo; <a href="custom-management-commands.html" title="アクションを自作する">前へ</a> 
     |
    <a href="index.html" title="HOWTO ガイド" accesskey="U">上へ</a>
   |
    <a href="custom-template-tags.html" title="テンプレートタグやフィルタを自作する">次へ</a> &raquo;</div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>