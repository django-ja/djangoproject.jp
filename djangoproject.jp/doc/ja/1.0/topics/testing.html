<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Djangoアプリケーションのテスト &mdash; Django v1.0 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.0',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="contents" title="Global table of contents" href="../contents.html" />
    <link rel="index" title="Global index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="top" title="Django v1.0 documentation" href="../index.html" />
    <link rel="up" title="Django を使う" href="index.html" />
    <link rel="next" title="Django でのユーザ認証" href="auth.html" />
    <link rel="prev" title="ファイルの管理" href="files.html" />
  </head>
  <body>
  <div id="outdated-warning" class="doc-floating-warning" style="position: relative;">
    このドキュメントの Django のバージョンにはセキュリティ上の脆弱性があるため、すでにサポートが終了されています。新しいバージョンにアップグレードしてください！<a href="https://docs.djangoproject.com/ja/">最新の Django のバージョンのドキュメントはこちら</a>
  </div>
  <div id="custom-doc" class="yui-t6">
    <div id="hd">
      <h1><a href="../index.html">Django v1.0 documentation</a></h1>
      <div id="global-nav">
        <a title="Home page" href="../index.html">ホーム</a>  |
        <a title="Table of contents" href="../contents.html">目次</a>  |
        <a title="Global index" href="../genindex.html">索引</a>  |
        <a title="Search" href="../modindex.html">モジュール一覧</a>
      </div>
      <div class="nav">
    &laquo; <a href="files.html" title="ファイルの管理">前へ</a> 
     |
    <a href="index.html" title="Django を使う" accesskey="U">上へ</a>
   |
    <a href="auth.html" title="Django でのユーザ認証">次へ</a> &raquo;</div>
    </div>
    
    <div id="bd">
      <div id="yui-main">
        <div class="yui-b">
          <div class="yui-g" id="topics-testing">
            
  
  <div class="section" id="s-module-django.test">
<span id="s-topics-testing"></span><h1>Djangoアプリケーションのテスト<a class="headerlink" href="#module-django.test" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">revision-up-to:</th><td class="field-body">8961 (1.0)</td>
</tr>
</tbody>
</table>
<p>今日の Web 開発者にとって、自動化されたテストはバグ潰しの工程で極めて有用な
ツールです。複数のテストを集めた <strong>テストスイート</strong> を使えば、Web開発におけ
るいくつもの問題を解決したり回避したりできます:</p>
<ul class="simple">
<li>新たなコードを書く際、コードが期待通りに動作するかテストできます。</li>
<li>以前のコードを修正したりリファクタする場合、テストによって、コードの変
更がアプリケーションに意図しない影響を及ぼさないか調べられます。</li>
</ul>
<p>Web アプリケーションは、 HTTP レベルのリクエスト処理、フォームの検証と処理、
そしてテンプレートレンダリングまで、複数のロジックレイヤから構成されていま
す。そのため、Webアプリケーションのテストは複雑なタスクです。 Django のテス
ト実行フレームワークと関連ユーティリティを使えば、仮想的なリクエストを発行
したり、テストデータを挿入したり、アプリケーションの出力を調べて、コードが
期待通りに動作しているか検証したりできます。</p>
<p>しかも素晴らしいことに、テストはとても簡単なのです。</p>
<p>このドキュメントは前後半の 2 つの節に別れています。前半では Django における
テストの書き方を、後半ではテストの実行方法を説明します。</p>
<div class="section" id="s-id1">
<span id="s-writing-tests"></span><h2>テストを書く<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>Django でテストを書く方法は主に 2 つあり、それぞれ Python の標準ライブラリ
についてくる二つのテストフレームワークに対応しています。フレームワークは以
下の 2 つです:</p>
<ul>
<li><p class="first"><strong>doctest</strong> &#8211; 関数やクラスの docstring (ドキュメンテーション文字列)
に埋め込まれたテストで、例えば以下のように Python の対話インタプリタ
セッションを模した方法で書かれています:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">my_func</span><span class="p">(</span><span class="n">a_list</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; a = [&#39;larry&#39;, &#39;curly&#39;, &#39;moe&#39;]</span>
<span class="sd">    &gt;&gt;&gt; my_func(a, 0)</span>
<span class="sd">    &#39;larry&#39;</span>
<span class="sd">    &gt;&gt;&gt; my_func(a, 1)</span>
<span class="sd">    &#39;curly&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">a_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
</pre></div>
</li>
<li><p class="first"><strong>ユニットテスト (unit test)</strong> -- 以下の例のように、テストを
<tt class="docutils literal"><span class="pre">unittest.TestCase`</span></tt> のサブクラスのメソッドとして表現したものです:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">unittest</span>

<span class="k">class</span> <span class="nc">MyFuncTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">testBasic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;larry&#39;</span><span class="p">,</span> <span class="s">&#39;curly&#39;</span><span class="p">,</span> <span class="s">&#39;moe&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEquals</span><span class="p">(</span><span class="n">my_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s">&#39;larry&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEquals</span><span class="p">(</span><span class="n">my_func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s">&#39;curly&#39;</span><span class="p">)</span>
</pre></div>
</li>
</ul>
<p>好みに応じて、どちらのテストを使ってもかまいませんし、両方のテストを組み合
わせてもかまいません。また、後でほんの少しだけ説明しますが、他のテストフレー
ムワークを使っても構いません。</p>
<div class="section" id="s-doctest">
<span id="s-writing-doctests"></span><h3>doctest を書く<a class="headerlink" href="#doctest" title="Permalink to this headline">¶</a></h3>
<p>doctest は、Python の標準モジュール、 <a class="reference external" href="http://python.jp/doc/release/lib/module-doctest.html">doctest</a> によるテストです。 doctest
は docstring (ドキュメンテーション文字列) から、 Python の対話インタプリタ
セッションの形式をとる部分を探し出して実行します。 doctest の詳しい構造につ
いての解説はこのドキュメントの範囲を超えた話なので、公式ドキュメントを参照
してください。</p>
<div class="admonition-docstring admonition">
<p class="first admonition-title"><strong>docstring</strong> とは?</p>
<p>docstring の詳しい説明 (と、効果的な docstring の書き方) は、
<span class="target" id="index-8"></span><a class="reference external" href="http://www.python.org/dev/peps/pep-0257"><strong>PEP 257</strong></a> (訳注: PEP 257 の和訳は
<a class="reference external" href="http://www.python.jp/doc/contrib/peps/pep-0257.txt">http://www.python.jp/doc/contrib/peps/pep-0257.txt</a> にあります) に書かれ
ています:</p>
<blockquote>
docstring とは、モジュールや関数、クラス、メソッド定義のブロック中
の先頭に置かれた文字列リテラルです。 docstring を定義すると、オブジェ
クトの <tt class="docutils literal"><span class="pre">__doc__</span></tt> という特殊な属性になります。</blockquote>
<p>例えば、下の関数には、関数の説明の入った docstring があります:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">add_two</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="s">&quot;引数に指定した数に 2 を加えて返します。&quot;</span>
    <span class="k">return</span> <span class="n">num</span> <span class="o">+</span> <span class="mi">2</span>
</pre></div>
<p class="last">テストはそれ自体素晴らしいドキュメントになることも多いので、テストをそ
のまま docstring に入れておけば、ドキュメント化とコードのテストの
<em>両方を</em> 効率的に行えます。</p>
</div>
<p>テストランナは、 Django アプリケーションの中の以下のファイルから doctest を
探して実行します:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">models.py</span></tt> ファイル。モジュールレベル、かつ/またはモデルレベルの
doctest を記述します。一般には、アプリケーションレベルの doctest はモ
ジュールの docstring として記述し、モデルレベルの docstring はモデル
クラスの docstring として記述します。</li>
<li>アプリケーションディレクトリ、すなわち <tt class="docutils literal"><span class="pre">models.py</span></tt> の入ったディレク
トリ下に置かれた <tt class="docutils literal"><span class="pre">tests.py</span></tt> という名前のファイル。このファイルは、
モデルに関係しないような doctest を書きたい場合のフックとして使えます。</li>
</ul>
<p>doctest の文字列は <tt class="docutils literal"><span class="pre">models.py</span></tt> の全てのオブジェクトに対して記述できますが、
慣習的には、アプリケーションレベルの doctest はモジュールの docstring に、
モデルレベルの doctest は各モデルの docstring に配置します。</p>
<p>モデル定義で doctest を使った例を示します:</p>
<div class="highlight"><pre><span class="c"># models.py</span>

<span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>

<span class="k">class</span> <span class="nc">Animal</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    鳴き声から動物を調べるテスト</span>

<span class="sd">    # 動物インスタンスを生成する</span>
<span class="sd">    &gt;&gt;&gt; lion = Animal.objects.create(name=&quot;lion&quot;, sound=&quot;roar&quot;)</span>
<span class="sd">    &gt;&gt;&gt; cat = Animal.objects.create(name=&quot;cat&quot;, sound=&quot;meow&quot;)</span>

<span class="sd">    # speak() を呼び出す</span>
<span class="sd">    &gt;&gt;&gt; lion.speak()</span>
<span class="sd">    &#39;The lion says &quot;roar&quot;&#39;</span>
<span class="sd">    &gt;&gt;&gt; cat.speak()</span>
<span class="sd">    &#39;The cat says &quot;meow&quot;&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">sound</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">speak</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;The </span><span class="si">%s</span><span class="s"> says &quot;</span><span class="si">%s</span><span class="s">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sound</span><span class="p">)</span>
</pre></div>
<p><a class="reference internal" href="#running-tests"><em>テストを実行する</em></a> と、テストユーティリティは上の
docstring を探し出して、Python の対話セッションに見える部分を検出し、そこに
書かれた命令を実行して、docstring に書かれた結果と実際の実行結果が一致する
かどうかを確かめます。</p>
<p>モデルテストの場合、テストランナが独自にテストデータベースを作成します。す
なわち、データベースに対してアクセスするテスト -- 例えば、モデルインスタン
スを生成して保存するようなテスト -- が、実運用のためのデータベースに影響を
及ぼすことはありません。 doctest はいずれも「白紙状態」、すなわち、各モデル
のデータベーステーブルが空の状態で実行されます (詳しくは、後述のフィクスチャ
の節を参照してください) 。この機能を使うには、 Django がデータベースに接続
するときのユーザに <tt class="docutils literal"><span class="pre">CREATE</span> <span class="pre">DATABASE</span></tt> の権限を持たせておかねばならないので
注意してください。</p>
<p>doctest の詳しい動作原理は、 <a class="reference external" href="http://python.jp/doc/release/lib/module-doctest.html">標準ドキュメントの doctest の項</a>
を参照してください。</p>
</div>
<div class="section" id="s-id4">
<span id="s-writing-unit-tests"></span><h3>ユニットテストを書く<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>Django の単体テストもまた、doctest と同様、標準ライブラリモジュールの
<a class="reference external" href="http://python.jp/doc/release/lib/module-unittest.html">unittest</a> を使います。このモジュールは、 <a class="reference external" href="http://python.jp/doc/release/lib/module-doctest.html">doctest</a> とは違った、 クラスベース
のやり方でテストを定義します。</p>
<p>doctest と同様、 Django のテストランナは、以下の二つの場所からユニットテス
トを探します:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">models.py</span></tt> ファイル。テストランナはこのモジュールから
<tt class="docutils literal"><span class="pre">unittest.TestCase</span></tt> のサブクラスを探します。</li>
<li>アプリケーションディレクトリ、すなわち <tt class="docutils literal"><span class="pre">models.py</span></tt> の入ったディレク
トリ下に置かれた <tt class="docutils literal"><span class="pre">tests.py</span></tt> という名前のファイル。上と同様に、テス
トランナはこのモジュールから <tt class="docutils literal"><span class="pre">unittest.TestCase</span></tt> のサブクラスを探し
ます。</li>
</ul>
<p>以下の <tt class="docutils literal"><span class="pre">unittest.TestCase</span></tt> のサブクラスは、前節の doctest と同じテストを
実現しています:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">unittest</span>
<span class="kn">from</span> <span class="nn">myapp.models</span> <span class="kn">import</span> <span class="n">Animal</span>

<span class="k">class</span> <span class="nc">AnimalTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lion</span> <span class="o">=</span> <span class="n">Animal</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;lion&quot;</span><span class="p">,</span> <span class="n">sound</span><span class="o">=</span><span class="s">&quot;roar&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cat</span> <span class="o">=</span> <span class="n">Animal</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;cat&quot;</span><span class="p">,</span> <span class="n">sound</span><span class="o">=</span><span class="s">&quot;meow&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">testSpeaking</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEquals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lion</span><span class="o">.</span><span class="n">speak</span><span class="p">(),</span> <span class="s">&#39;The lion says &quot;roar&quot;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEquals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">speak</span><span class="p">(),</span> <span class="s">&#39;The cat says &quot;meow&quot;&#39;</span><span class="p">)</span>
</pre></div>
<p><a class="reference internal" href="#running-tests"><em>テストを実行する</em></a> と、テストユーティリティはデフォル
トの動作として、 <tt class="docutils literal"><span class="pre">models.py</span></tt> と <tt class="docutils literal"><span class="pre">tests.py</span></tt> に入っている全てのテストケー
ス (つまり <tt class="docutils literal"><span class="pre">unittest.TestCase</span></tt> のサブクラス) を捜し出し、そこからテストス
イートを自動的に構築して、スイートを実行します。</p>
<p>開発バージョンの Django には、あるモジュールのテストスイートを定義する方法
をもう一つ提供しています:  <tt class="docutils literal"><span class="pre">models.py</span></tt> や <tt class="docutils literal"><span class="pre">tests.py</span></tt> で <tt class="docutils literal"><span class="pre">suite()</span></tt> メ
ソッドを定義している場合、 Django のテストランナはこのメソッドを使ってテス
トスイートを構築します。この仕様は、ユニットテストにおいて
<a class="reference external" href="http://python.jp/doc/release/lib/organizing-tests.html">おすすめのテストスイート構築方法</a> に従っています。複雑なテストスイー
トの構築方法についての詳細は Python のドキュメントを参照してください。</p>
<p><tt class="docutils literal"><span class="pre">unittest</span></tt> の詳細は <a class="reference external" href="http://python.jp/doc/release/lib/module-unittest.html">標準ライブラリドキュメントの unittest の項</a> を参照
してください。</p>
</div>
<div class="section" id="s-id7">
<span id="s-which-should-i-use"></span><h3>どちらのテストを使うべきか<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>Django は標準的な Python テストフレームワークの両方をサポートしているので、
どちらを選ぶかは、開発者個々人の好み次第です。もちろん、 <em>両方</em> を同時に使っ
てもかまいません。</p>
<p>とはいえ、テストを初めて書く開発者にとっては、この選択は混乱
のもとになるでしょう。そこで、どちらのテストを使うべきかを決める手がかりに
なるよう、 doctest と単体テストの主な違いについて示します:</p>
<ul>
<li><p class="first">そこそこ Python に慣れているなら、 <tt class="docutils literal"><span class="pre">doctest</span></tt> の方がより「Python的
(pythonic)」に感じることでしょう。 doctest はテストをできるだけ楽に書け
るように設計されているので、クラスやメソッドを書くときのオーバヘッドが
ほとんどありません。単に docstring にテストを書くだけでよいのです。それ
に、モジュールに対してドキュメントを自動生成させられるという利点もあり
ます。つまり、 doctest を上手に書けば、ドキュメント作成とテストを同時に
片付けられて一石二鳥、というわけです。</p>
<p>また、テストにまだ慣れていない開発者は、 doctest を使った方が早くテスト
について学べることでしょう。</p>
</li>
<li><p class="first">Java での開発経験のある開発者なら、 <tt class="docutils literal"><span class="pre">unittest</span></tt> フレームワークはとても
理解しやすいはずです。 <tt class="docutils literal"><span class="pre">unittest</span></tt> は Java の JUnit に影響を受けている
ので、他の言語で JUnit から派生したテストフレームワークを使ったことがあ
るのなら、<tt class="docutils literal"><span class="pre">unittest</span></tt> はかなりしっくりくるはずです。</p>
</li>
<li><p class="first">同じコードを含むような一連のテストを書くときには、 <tt class="docutils literal"><span class="pre">unittest</span></tt> フレー
ムワークのクラスとメソッドによる設計が気に入るでしょう。共通のタスクを
抽象化して、メソッド化できるからです。また、 <tt class="docutils literal"><span class="pre">unittest</span></tt> フレームワー
クは <tt class="docutils literal"><span class="pre">unittest</span></tt> はテストの初期化／終了処理のルーチンをサポートしてい
るので、テストケースを実行するときの環境を高い水準でコントロールできま
す。</p>
</li>
</ul>
<p>繰り返しになりますが、(一つのアプリケーションの中であっても) 両方のシステム
を並べて使えることを忘れないでください。どちらのテストシステムにも、状況に
応じて適した部分があるので、大抵のプロジェクトでは、最終的には両方のテスト
システムを使うことになるものです。</p>
</div>
</div>
<div class="section" id="s-id9">
<span id="s-id8"></span><span id="s-running-tests"></span><h2>テストを実行する<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>テストを実行するには、プロジェクトの <tt class="docutils literal"><span class="pre">manage.py</span></tt> ユーティリティを使います:</p>
<pre>$ ./manage.py test</pre>
<p>特定のアプリケーションに対してテストを実行したければ、コマンドラインにアプ
リケーションの名前を追加します。例えば、 <a class="reference external" href="../ref/settings.html#setting-INSTALLED_APPS"><tt class="xref docutils literal"><span class="pre">INSTALLED_APPS</span></tt></a> に
<tt class="docutils literal"><span class="pre">myproject.polls</span></tt> と <tt class="docutils literal"><span class="pre">myproject.animals</span></tt> というアプリケーションが入って
おり、 animals の単体テストを実行したいだけなら、以下のようにします:</p>
<pre>$ ./manage.py test animals</pre>
<p><tt class="docutils literal"><span class="pre">animals</span></tt> ではなく、 <tt class="docutils literal"><span class="pre">myproject.animals</span></tt> なので注意してください。</p>
<div class="versionadded">
<span class="title">Django 1.0 で新たに登場しました:</span> 実行したいテストを選べるようになりました。</div>
<p>単体テストを実行する際、どのテストを実行するかを指定できます。あるアプリケー
ション用のテストケースを実行する場合 (例えば、上で解説した AnimalTestCase
の場合) は、コマンドラインにテストケースの名前を追加してください:</p>
<pre>$ ./manage.py test animals.AnimalTestCase</pre>
<p>テストケース中の個別のテストメソッドを実行したければ、メソッド名を指定して
ください:</p>
<pre>$ ./manage.py test animals.AnimalTestCase.testFluffyAnimals</pre>
<div class="section" id="s-id10">
<span id="s-the-test-database"></span><h3>テストデータベース<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>データベースを必要とするテスト (モデルのテスト) に、「本番の (実運用環境の)」
データベースは必要ありません。テストの際には、空の別のデータベースが作成さ
れます。</p>
<p>テストがパスするか失敗するかに関わらず、テストデータベースは全てのテストを
実行し終えると消去されます。</p>
<p>デフォルトでは、
.. _Understanding the test output:</p>
</div>
<div class="section" id="s-id11">
<h3>テストの出力を理解する<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>テストを実行すると、まずテストランナ自身の初期化メッセージが表示されます:</p>
<pre>Creating test database...
Creating table myapp_animal
Creating table myapp_mineral
Loading 'initial_data' fixtures...
No fixtures found.</pre>
<p>このメッセージは、テストランナがテストデータベースを作成したことを示してい
ます。テストデータベースは、空の、何もない状態から作成したデータベースで、
(モデルテストのような) データベースの必要なテストで使われます。</p>
<p>デフォルトでは、テストデータベースの名前は、 <a class="reference external" href="../ref/settings.html#setting-DATABASE_NAME"><tt class="xref docutils literal"><span class="pre">DATABASE_NAME</span></tt></a> に指
定したデータベース名の前に <tt class="docutils literal"><span class="pre">test_</span></tt> を付けたものです。 SQLite データベース
エンジンを使っている場合、デフォルトではテストをメモリ上のデータベースで行
います(すなわち、データベースをメモリ上に生成し、ファイルシステムを全く経由
しません！) 。テストデータベースの名前をデフォルト意外の値にしたければ、
<a class="reference external" href="../ref/settings.html#setting-TEST_DATABASE_NAME"><tt class="xref docutils literal"><span class="pre">TEST_DATABASE_NAME</span></tt></a> 設定を使って指定します。</p>
<p>テスト用に別のデータベースを使うことを除けば、テストランナは設定ファイルの
データベースに関する他の設定、 <a class="reference external" href="../ref/settings.html#setting-DATABASE_ENGINE"><tt class="xref docutils literal"><span class="pre">DATABASE_ENGINE</span></tt></a>,
<a class="reference external" href="../ref/settings.html#setting-DATABASE_USER"><tt class="xref docutils literal"><span class="pre">DATABASE_USER</span></tt></a>, <a class="reference external" href="../ref/settings.html#setting-DATABASE_HOST"><tt class="xref docutils literal"><span class="pre">DATABASE_HOST</span></tt></a> などをそのまま使います。
テストデータベースは <a class="reference external" href="../ref/settings.html#setting-DATABASE_USER"><tt class="xref docutils literal"><span class="pre">DATABASE_USER</span></tt></a> の権限で作成されるので、この
ユーザは新たに生成されたデータベースを操作する権限を備えていなければなりま
せん。</p>
<div class="versionadded">
<span class="title">Django 1.0 で新たに登場しました.</span> </div>
<p>テスト用データベースの文字セットエンコーディング設定を細かく調整したいのな
ら、 <a class="reference external" href="../ref/settings.html#setting-TEST_DATABASE_CHARSET"><tt class="xref docutils literal"><span class="pre">TEST_DATABASE_CHARSET</span></tt></a> 設定を使ってください。 MySQL を使って
いるなら、 <a class="reference external" href="../ref/settings.html#setting-TEST_DATABASE_COLLATION"><tt class="xref docutils literal"><span class="pre">TEST_DATABASE_COLLATION</span></tt></a> でテストデータベースで使うコ
レーション(collation) を指定できます。これらの設定については、
<a class="reference external" href="../ref/settings.html#ref-settings"><em>settings ファイルのドキュメント</em></a> を参照してください。</p>
</div>
<div class="section" id="s-id12">
<h3>その他のテスト条件<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>設定ファイル上の <a class="reference external" href="../ref/settings.html#setting-DEBUG"><tt class="xref docutils literal"><span class="pre">DEBUG</span></tt></a> の値にかかわらず、 Django は全てのテスト
を <tt class="xref docutils literal"><span class="pre">DEBUG=False</span></tt> で動かします。これは、テストコードに実運用環境と
同じ内容を出力させるためです。</p>
</div>
<div class="section" id="s-id13">
<span id="s-understanding-the-test-output"></span><h3>テストプログラムの出力を理解する<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>テストを実行すると、テストランナ自体が大量に出力するメッセージに出くわすで
しょう。コマンドラインの <tt class="docutils literal"><span class="pre">verbosity</span></tt> オプションを使えば、メッセージの詳細
レベルを制御できます:</p>
<pre>Creating test database...
Creating table myapp_animal
Creating table myapp_mineral
Loading 'initial_data' fixtures...
No fixtures found.</pre>
<p>上のメッセージは、テストランナがデータベースをテストしたことを示します。</p>
<p>テストデータベースが生成されると、 Django はテストを実行します。全てのテス
トにパスすると、最後には以下のようなメッセージが表示されます:</p>
<pre>----------------------------------------------------------------------
Ran 22 tests in 0.221s

OK</pre>
<p>一方、失敗したテストがあると、失敗したテストに関する詳しい情報が表示されま
す:</p>
<pre>======================================================================
FAIL: Doctest: ellington.core.throttle.models
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/dev/django/test/doctest.py", line 2153, in runTest
    raise self.failureException(self.format_failure(new.getvalue()))
AssertionError: Failed doctest test for myapp.models
  File "/dev/myapp/models.py", line 0, in models

----------------------------------------------------------------------
File "/dev/myapp/models.py", line 14, in myapp.models
Failed example:
    throttle.check("actor A", "action one", limit=2, hours=1)
Expected:
    True
Got:
    False

----------------------------------------------------------------------
Ran 2 tests in 0.048s

FAILED (failures=1)</pre>
<p>エラー出力の詳細はこのドキュメントの範囲を超えるので解説はしませんが、ほと
んど直感的に理解できる内容のはずです。詳しくは、 Python の <tt class="docutils literal"><span class="pre">unittest</span></tt> ラ
イブラリのドキュメントを参照してください。</p>
<p>スクリプトのリターンコードは失敗したテストや出力のおかしかったテストの総数で
す。全てのテストにパスしていれば、リターンコードは 0 です。この仕様は、テス
トランナをシェルスクリプト上で動かしたり、テストが成功したかどうかをテスト
ランナのレベルで調べたい場合に便利です。</p>
</div>
</div>
<div class="section" id="s-id14">
<span id="s-testing-tools"></span><h2>テスト用のツール<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h2>
<p>Django は、テストを書くときに便利なツールをいくつか提供しています。</p>
<div class="section" id="s-module-django.test.client">
<span id="s-the-test-client"></span><h3>テストクライアント<a class="headerlink" href="#module-django.test.client" title="Permalink to this headline">¶</a></h3>
<p>テストクライアント (test client) は、簡単なダミーブラウザとして動作する
Python のクラスです。テストクライアントを使うと、ビューをテストしたり、
プログラムを使ってDjango で作られたアプリケーションとやりとりできます。</p>
<p>テストクライアントを使ってできることをいくつか挙げましょう:</p>
<ul class="simple">
<li>ある URL に対する GET や POST をシミュレートでき、低水準の HTTP (レスポ
ンスヘッダや状態コード) 情報から、ページの内容まで、リクエストに対するレ
スポンスの全てを調べられます。</li>
<li>特定の URL に対して正しいビューが呼び出されるかどうかを調べられます。</li>
<li>特定のリクエストに対して、特定のテンプレートを使ったレンダリングが行わ
れ、その際に特定の値が入ったコンテキストが使われているかどうかを調べら
れます。</li>
</ul>
<p>テストクライアントは <a class="reference external" href="http://twill.idyll.org/">Twill</a> や <a class="reference external" href="http://www.openqa.org/selenium/">Selenium</a> やその他のブラウザ自動化フレームワー
クを置き換えようとするものではありません。 Django のテストクライアントはもっ
と別の部分に焦点を当てているのです。すなわち:</p>
<ul class="simple">
<li>正しいビューが呼び出され、ビューが正しいコンテキストデータを生成してい
るかどうかは、 Django のテストクライアントを使って調べてください。</li>
<li>Twill や Selenium は、 <em>レンダリング済みの</em> HTML や、 JavaScript の機能
のような Web ページの <em>ビヘイビア</em> のテストに使ってください。</li>
</ul>
<p>網羅的なテストスイートでは、両方のタイプのテストを組み合わせて使うはずです。</p>
<div class="section" id="s-id16">
<span id="s-overview-and-a-quick-example"></span><h4>テストの概要と簡単な例<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<p>テストクライアントを使うには、 <tt class="docutils literal"><span class="pre">django.test.client.Client</span></tt> をインスタンス
化して、 Web ページを取得します:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.test.client</span> <span class="kn">import</span> <span class="n">Client</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Client</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s">&#39;/login/&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s">&#39;username&#39;</span><span class="p">:</span> <span class="s">&#39;john&#39;</span><span class="p">,</span> <span class="s">&#39;password&#39;</span><span class="p">:</span> <span class="s">&#39;smith&#39;</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span><span class="o">.</span><span class="n">status_code</span>
<span class="go">200</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;/customer/details/&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span><span class="o">.</span><span class="n">content</span>
<span class="go">&#39;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 ...&#39;</span>
</pre></div>
<p>上の例でわかるように、 <tt class="docutils literal"><span class="pre">Client</span></tt> は Python 対話インタプリタのセッション中
でもインスタンス化できます。</p>
<p>テストクライアントの動作には重要な点がいくつかあります:</p>
<ul>
<li><p class="first">テストクライアントを実行するために Web サーバを起動する必要は
<em>ありません</em> 。実際、 Web サーバがまったく動いていなくても、テストは
何の問題もなく実行できるのです。というのも、テストクライアントは HTTP
通信のオーバヘッドを回避して、 Django フレームワークに直接アクセスし
ているからです。このからくりによって、ユニットテストを高速に実行でき
ます。</p>
</li>
<li><p class="first">ページを取得するときには、ドメインを含まない <em>パス部分だけ</em> を指定す
るよう気をつけてください。例えば、以下の呼び出し:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;/login/&#39;</span><span class="p">)</span>
</pre></div>
<p>は正しいですが、次の呼び出し:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;http://www.example.com/login/&#39;</span><span class="p">)</span>
</pre></div>
<p>は正しくありません。</p>
<p>Django のプロジェクトから生成されていない Web ページは、テストクライ
アントで取得できません。Django 以外の Web ページを取得したければ、
<a class="reference external" href="http://docs.python.org/lib/module-urllib.html">urllib</a> や <a class="reference external" href="http://docs.python.org/lib/module-urllib2.html">urllib2</a> のような Python 標準ライブラリを使ってください。</p>
</li>
<li><p class="first">テストクライアントは URL の解決に <a class="reference external" href="../ref/settings.html#setting-ROOT_URLCONF"><tt class="xref docutils literal"><span class="pre">ROOT_URLCONF</span></tt></a> に指定され
た URLconf を使います。</p>
</li>
<li><p class="first">上の例は Python の対話インタプリタ中でも動作しますが、一部のテンプレー
ト関連の機能などは <em>テストの実行中だけ</em> でしか使えません。</p>
<p>というのも、 Django のテストランナは、あるビューでどのテンプレートが
ロードされるかを決定するためにちょっとした黒魔術的なコードを使ってい
るからです。この黒魔術 (実際には、メモリ上のテンプレートシステムに対
するパッチ) は、テスト実行時にしか適用されません。</p>
</li>
</ul>
</div>
<div class="section" id="s-id17">
<span id="s-making-requests"></span><h4>リクエスト生成<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h4>
<p>リクエストの生成には、 <tt class="docutils literal"><span class="pre">django.test.client.Client</span></tt> クラスを使います。
<tt class="docutils literal"><span class="pre">Client</span></tt> は引数なしで生成します。:</p>
<dl class="class">
<dt id="django.test.client.Client">
<!--[django.test.client.Client]-->class <tt class="descname">Client</tt><a class="headerlink" href="#django.test.client.Client" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">Client</span></tt> のインスタンスからは、以下のメソッドを呼び出せます:</p>
<dl class="method">
<dt id="django.test.client.Client.get">
<!--[django.test.client.Client.get]--><tt class="descname">get</tt>(<em>path</em>, <em>data={}</em>)<a class="headerlink" href="#django.test.client.Client.get" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">path</span></tt> に対する GET リクエストを行い、 <tt class="docutils literal"><span class="pre">Response</span></tt> オブジェクト
を返します。 <tt class="docutils literal"><span class="pre">Response</span></tt> オブジェクトについては後で説明します。</p>
<p>引数 <tt class="docutils literal"><span class="pre">data</span></tt> は辞書オブジェクトで、キー／値のペアが GET データのペ
イロードの生成に使われます。例えば:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Client</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;/customers/details/&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s">&#39;name&#39;</span><span class="p">:</span><span class="s">&#39;fred&#39;</span><span class="p">,</span> <span class="s">&#39;age&#39;</span><span class="p">:</span><span class="mi">7</span><span class="p">})</span>
</pre></div>
<p>は、以下のような GET リクエストの送信と同じです:</p>
<pre>/customers/details/?name=fred&amp;age=7</pre>
</dd></dl>

<dl class="method">
<dt id="django.test.client.Client.post">
<!--[django.test.client.Client.post]--><tt class="descname">post</tt>(<em>path</em>, <em>data={}</em>, <em>content_type=MULTIPART_CONTENT</em>)<a class="headerlink" href="#django.test.client.Client.post" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">path</span></tt> に対する POST リクエストを行い、 <tt class="docutils literal"><span class="pre">Response</span></tt> オブジェクト
を返します。</p>
<p>引数 <tt class="docutils literal"><span class="pre">data</span></tt> は辞書オブジェクトで、キー／値のペアが POST データの
ペイロード生成に使われます。例えば:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Client</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s">&#39;/login/&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s">&#39;name&#39;</span><span class="p">:</span> <span class="s">&#39;fred&#39;</span><span class="p">,</span> <span class="s">&#39;passwd&#39;</span><span class="p">:</span> <span class="s">&#39;secret&#39;</span><span class="p">})</span>
</pre></div>
<p>は、以下のパス:</p>
<pre>/login/</pre>
<p>への POST リクエストで、以下の POST データ:</p>
<div class="highlight"><pre><span class="n">name</span><span class="o">=</span><span class="n">fred</span><span class="o">&amp;</span><span class="n">passwd</span><span class="o">=</span><span class="n">secret</span>
</pre></div>
<p>を伴います。</p>
<p><tt class="docutils literal"><span class="pre">content_type</span></tt> を指定した場合 (例えば XML ペイロードの場合には
<tt class="docutils literal"><span class="pre">text/xml</span></tt>)、引数 <tt class="docutils literal"><span class="pre">data</span></tt> の中身は POST リクエストそのままで送信
され、 <tt class="docutils literal"><span class="pre">Content-Type</span></tt> ヘッダに <tt class="docutils literal"><span class="pre">content_type</span></tt> の値を使います。</p>
<p><tt class="docutils literal"><span class="pre">content_type</span></tt> を指定しなければ、 <tt class="docutils literal"><span class="pre">data</span></tt> の中身は
<tt class="docutils literal"><span class="pre">multipart/form-data</span></tt> で送信されます。この場合、 <tt class="docutils literal"><span class="pre">data</span></tt> の中の
キー／値のペアは、マルチパートメッセージにエンコードされ、 POST デー
タのペイロード生成に使われます。</p>
<p>あるキーに対して複数の値を提出 (submit) する場合 (例えば、
<tt class="docutils literal"><span class="pre">&lt;select</span> <span class="pre">multiple&gt;</span></tt> の選択結果を指定する場合など) は、キーに対す
る値をリストやタプルにしてください。例えば、<tt class="docutils literal"><span class="pre">choices</span></tt> という名前
のフィールドから 3 つの行を選択して提出したければ:</p>
<div class="highlight"><pre><span class="sb">``</span><span class="p">{</span><span class="s">&#39;choices&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">)}</span><span class="sb">``</span>
</pre></div>
<p>のようにします。</p>
<p>ファイルの送信には特別な扱いが必要です。ファイルの POST を行う場合、
以下のように、ファイル名フィールドの名前をキーに、アップロードした
いファイルのファイルハンドルを値に設定します:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Client</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;wishlist.doc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">post</span><span class="p">(</span><span class="s">&#39;/customers/wishes/&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s">&#39;name&#39;</span><span class="p">:</span><span class="s">&#39;fred&#39;</span><span class="p">,</span> <span class="s">&#39;attachment&#39;</span><span class="p">:</span><span class="n">f</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
<p>(<tt class="docutils literal"><span class="pre">attachment</span></tt> という名前には特に意味はありません。ファイルを処理
するコードで使いたい名前を指定してください)</p>
<p>送信するファイルのハンドルは、 <tt class="docutils literal"><span class="pre">post()</span></tt> 後に手動で閉じねばならな
いので注意してください。</p>
</dd></dl>

<dl class="method">
<dt id="django.test.client.Client.login">
<!--[django.test.client.Client.login]--><tt class="descname">login</tt>(<em>**credentials</em>)<a class="headerlink" href="#django.test.client.Client.login" title="Permalink to this definition">¶</a></dt>
<dd><div class="versionadded">
<span class="title">Django 1.0 で新たに登場しました.</span> </div>
<p>Django の <a class="reference external" href="auth.html#topics-auth"><em>認証システム</em></a> を使っていて、ログイン
済みのユーザを扱う必要がある場合、テストクライアントの <tt class="docutils literal"><span class="pre">login()</span></tt>
メソッドを使えば、サイトへログインするユーザをシミュレートできます。</p>
<p>このメソッドを呼び出すと、テストクライアントはログインに必要なクッ
キーとセッションデータを持つようになり、テスト対象のビューのうち、
ログインの必要なテストをパスできるようになります。</p>
<p><tt class="docutils literal"><span class="pre">credentials</span></tt> 引数の形式は、使っている
<a class="reference external" href="auth.html#authentication-backends"><em>認証バックエンド</em></a> によって変わりま
す (認証バックエンドは <a class="reference external" href="../ref/settings.html#setting-AUTHENTICATION_BACKENDS"><tt class="xref docutils literal"><span class="pre">AUTHENTICATION_BACKENDS</span></tt></a> で設定し
ます)。    Django が提供している標準の認証バックエンド
(<tt class="docutils literal"><span class="pre">ModelBackend</span></tt>) を使う場合、 <tt class="docutils literal"><span class="pre">credentials</span></tt> にはユーザのユーザ
名とパスワードをキーワー引数で指定します:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Client</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">login</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="s">&#39;fred&#39;</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="s">&#39;secret&#39;</span><span class="p">)</span>
<span class="go"># これでログイン保護されたビューに入れるようになりました。</span>
</pre></div>
<p>認証バックエンドを変えた場合、このメソッドは違った認証情報を要求す
るかもしれません。その場合、 <tt class="docutils literal"><span class="pre">login()</span></tt> は、認証バックエンドの
<tt class="docutils literal"><span class="pre">authenticate()</span></tt> メソッドが必要とする認証情報をそのまま要求します。</p>
<p><tt class="docutils literal"><span class="pre">login()</span></tt> は、指定した認証情報が承認され、ログインに成功した場合に
<tt class="xref docutils literal"><span class="pre">True</span></tt> を返します。</p>
<p>このメソッドを使うには、事前にユーザを登録しておかねばなりません。上
で説明したように、テストランナはテストデータベースを使ってテストを実
行するので、デフォルトではユーザが登録されていません。そのため、運用
環境で使えるユーザはテスト環境では使えないのです。テストスイートの一
環として、手動で (Django のモデル API を使って) ユーザを作成するか、
フィクスチャでユーザを登録してください。</p>
</dd></dl>

<dl class="method">
<dt id="django.test.client.Client.logout">
<!--[django.test.client.Client.logout]--><tt class="descname">logout</tt>()<a class="headerlink" href="#django.test.client.Client.logout" title="Permalink to this definition">¶</a></dt>
<dd><p>Django の <a class="reference external" href="auth.html#topics-auth"><em>認証システム</em></a> を使っている場合、
<tt class="docutils literal"><span class="pre">logout()</span></tt> メソッドで、サイトからユーザをログアウトさせる効果をシ
ミュレートできます。</p>
<p>このメソッドを呼び出すと、テストクライアントはクッキーとセッション
データを全て消去して、デフォルトの状態に戻します。それ以降のリクエ
ストは、ビューからは <tt class="docutils literal"><span class="pre">AnonymousUser</span></tt> から送信されたリクエストとみ
なされます。</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="s-id18">
<span id="s-testing-responses"></span><h4>レスポンスのテスト<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h4>
<p><tt class="docutils literal"><span class="pre">get()</span></tt> および <tt class="docutils literal"><span class="pre">post()</span></tt> メソッドは、いずれも <tt class="docutils literal"><span class="pre">Response</span></tt> オブジェクト
を返します。 <tt class="docutils literal"><span class="pre">Response</span></tt> オブジェクトは Django のビューが返す
<tt class="docutils literal"><span class="pre">HttpResponse</span></tt> オブジェクトと同じ <em>ではありません</em> 。このオブジェクトは
検証用のテストコード作成に便利なデータをいくつか備えています。</p>
<p><tt class="docutils literal"><span class="pre">Response</span></tt> オブジェクトには以下のようなプロパティがあります:</p>
<dl class="class">
<dt id="django.test.client.Response">
<!--[django.test.client.Response]-->class <tt class="descname">Response</tt><a class="headerlink" href="#django.test.client.Response" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="django.test.client.Response.client">
<!--[django.test.client.Response.client]--><tt class="descname">client</tt><a class="headerlink" href="#django.test.client.Response.client" title="Permalink to this definition">¶</a></dt>
<dd>レスポンス要求の生成に使われたテストクライアントです。</dd></dl>

<dl class="attribute">
<dt id="django.test.client.Response.content">
<!--[django.test.client.Response.content]--><tt class="descname">content</tt><a class="headerlink" href="#django.test.client.Response.content" title="Permalink to this definition">¶</a></dt>
<dd>レスポンスの本体部分 (body) です。ビューがレンダリングによって生成
した最終的なページコンテンツか、エラーメッセージです。</dd></dl>

<dl class="attribute">
<dt id="django.test.client.Response.context">
<!--[django.test.client.Response.context]--><tt class="descname">context</tt><a class="headerlink" href="#django.test.client.Response.context" title="Permalink to this definition">¶</a></dt>
<dd><p>レスポンスのページコンテンツのレンダに使われた <tt class="docutils literal"><span class="pre">Context</span></tt> オブジェ
クトです。</p>
<p>複数のテンプレートを使ってレンダリングを行った場合、 <tt class="docutils literal"><span class="pre">context</span></tt> は
<tt class="docutils literal"><span class="pre">Context</span></tt> オブジェクトをレンダリングで使った順に並べたリストです。</p>
</dd></dl>

<dl class="attribute">
<dt id="django.test.client.Response.request">
<!--[django.test.client.Response.request]--><tt class="descname">request</tt><a class="headerlink" href="#django.test.client.Response.request" title="Permalink to this definition">¶</a></dt>
<dd>レスポンスを得るために使用したリクエストデータです。</dd></dl>

<dl class="attribute">
<dt id="django.test.client.Response.status_code">
<!--[django.test.client.Response.status_code]--><tt class="descname">status_code</tt><a class="headerlink" href="#django.test.client.Response.status_code" title="Permalink to this definition">¶</a></dt>
<dd>レスポンスの HTTP 状態コードです。全ての HTTP 状態コードのリストは
<a class="reference external" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">RFC2616</a> を参照してください。</dd></dl>

<dl class="attribute">
<dt id="django.test.client.Response.template">
<!--[django.test.client.Response.template]--><tt class="descname">template</tt><a class="headerlink" href="#django.test.client.Response.template" title="Permalink to this definition">¶</a></dt>
<dd><p>最終的なページコンテンツのレンダリングに使われた <tt class="docutils literal"><span class="pre">Template</span></tt> のイ
ンスタンスです。テンプレートをファイルからロードした場合、テンプレー
トのファイル名を <tt class="docutils literal"><span class="pre">template.name</span></tt> で調べられます
(<tt class="docutils literal"><span class="pre">'admin/index.html'</span></tt> のような形式の文字列です)。</p>
<p>複数のテンプレートをレンダリングしている場合 (例えば
<a class="reference external" href="templates.html#template-inheritance"><em>テンプレートの継承</em></a> を使っている場合)、
<tt class="docutils literal"><span class="pre">template</span></tt> はレンダリング順に並んだ  <tt class="docutils literal"><span class="pre">Template</span></tt> オブジェクトの
リストです。</p>
</dd></dl>

</dd></dl>

<p>また、レスポンスオブジェクトを辞書のように扱っても、HTTPヘッダに設定された
値にアクセスできます。例えば、レスポンスのコンテンツタイプは
<tt class="docutils literal"><span class="pre">response['Content-Type']</span></tt> でアクセスできます。</p>
</div>
<div class="section" id="s-id19">
<h4>例外<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h4>
<p>テストクライアントのアクセス先のビューが例外を送出するような場合、テストケー
ス内で例外にアクセスできます。例外のテストを行うには、通常の
<tt class="docutils literal"><span class="pre">try...catch</span></tt> ブロックか、 <tt class="docutils literal"><span class="pre">unittest.TestCase.assertRaises()</span></tt> を使いま
す。</p>
<p>ただし、 <tt class="docutils literal"><span class="pre">Http404</span></tt> や <tt class="docutils literal"><span class="pre">PermissionDenied</span></tt>, <tt class="docutils literal"><span class="pre">SystemExit</span></tt> といった例外は
テストケースからアクセスできません。 Django はこれらの例外を内部的に捕捉し
て、対応する適切な HTTP 応答コードに変換してしまうからです。これらの例外に
対しては、 <tt class="docutils literal"><span class="pre">response.status_code</span></tt> のチェックで対応してください。</p>
</div>
<div class="section" id="s-id20">
<span id="s-persistent-state"></span><h4>セッションの永続性<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h4>
<p>テストクライアントの動作はステートフルです。あるレスポンスにクッキーが入っ
ていると、クッキーはテストクライアント中に保存され、それ以降の <tt class="docutils literal"><span class="pre">get()</span></tt> や
<tt class="docutils literal"><span class="pre">post()</span></tt> リクエストで使われます。</p>
<p>テストクライアントは、クッキーの有効期限ポリシを守りません。クッキーを期限
切れにしたければ、該当クッキーを <tt class="docutils literal"><span class="pre">client.cookies</span></tt> から手動で削除するか、
新たな <tt class="docutils literal"><span class="pre">Client</span></tt> インスタンスを生成してください (全てのクッキーを除去しま
す)。</p>
<p>テストクライアントには、永続セッション情報 (persistent state information)
を保存するためのプロパティが二つあります。これらのプロパティは、必要に応じ
てテスト条件の一部として検査できます。</p>
<dl class="attribute">
<dt id="django.test.client.Client.cookies">
<!--[django.test.client.Client.cookies]--><tt class="descclassname">Client.</tt><tt class="descname">cookies</tt><a class="headerlink" href="#django.test.client.Client.cookies" title="Permalink to this definition">¶</a></dt>
<dd>Python の <tt class="docutils literal"><span class="pre">SimpleCookie</span></tt> 型のオブジェクトで、全てのクライアントクッキー
の現在値が入っています。詳しくは <a class="reference external" href="http://docs.python.org/lib/module-Cookie.html">Cookie モジュールのドキュメント</a> を
参照してください。</dd></dl>

<dl class="attribute">
<dt id="django.test.client.Client.session">
<!--[django.test.client.Client.session]--><tt class="descclassname">Client.</tt><tt class="descname">session</tt><a class="headerlink" href="#django.test.client.Client.session" title="Permalink to this definition">¶</a></dt>
<dd>セッション情報の入った辞書ライクなオブジェクトです。詳しくは
<a class="reference external" href="http/sessions.html#topics-http-sessions"><em>セッションのドキュメント</em></a> を参照してくださ
い。</dd></dl>

</div>
<div class="section" id="s-id21">
<h4>ユニットテストの例<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h4>
<p>テストクライアントを使った簡単なユニットテストを以下に示します:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">unittest</span>
<span class="kn">from</span> <span class="nn">django.test.client</span> <span class="kn">import</span> <span class="n">Client</span>

<span class="k">class</span> <span class="nc">SimpleTest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># unittest を使う場合、毎回 Client を生成する必要があります。</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">test_details</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># GET リクエストを発行します。</span>
        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;/customer/details/&#39;</span><span class="p">)</span>

        <span class="c"># レスポンスが 200 OK であるか調べます。</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failUnlessEqual</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">status_code</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>

        <span class="c"># レンダリングされるコンテキストの customers の長さが 5 である</span>
        <span class="c"># か確かます。</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failUnlessEqual</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">context</span><span class="p">[</span><span class="s">&#39;customers&#39;</span><span class="p">]),</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="s-id22">
<span id="s-testcase"></span><h3>TestCaseクラス<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h3>
<p>Django は拡張用に以下のベースクラスを提供しています:</p>
<dl class="class">
<dt id="django.test.TestCase">
<!--[django.test.TestCase]-->class <tt class="descname">TestCase</tt><a class="headerlink" href="#django.test.TestCase" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>を提供しています。このクラスは、Web サイトのテスト時に便利な機能をいくつか
追加しています。</p>
<p>通常のユニットテストを <tt class="docutils literal"><span class="pre">unittest.TestCase</span></tt> から Django 独自の
<tt class="docutils literal"><span class="pre">TestCase</span></tt> に移行するのは簡単で、単にベースクラスを <tt class="docutils literal"><span class="pre">unittest.TestCase</span></tt>
から <tt class="docutils literal"><span class="pre">django.test.TestCase</span></tt> に変更するだけです。 <tt class="docutils literal"><span class="pre">django.test.TestCase</span></tt>
は、標準の Python ユニットテスト機能はそのままに、さらに便利な機能を提供し
ています。</p>
<div class="section" id="s-id23">
<span id="s-default-test-client"></span><h4>デフォルトのテストクライアント<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h4>
<div class="versionadded">
<span class="title">Django 1.0 で新たに登場しました.</span> </div>
<dl class="attribute">
<dt id="django.test.TestCase.client">
<!--[django.test.TestCase.client]--><tt class="descclassname">TestCase.</tt><tt class="descname">client</tt><a class="headerlink" href="#django.test.TestCase.client" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p><tt class="docutils literal"><span class="pre">django.test.TestCase</span></tt> クラスのインスタンス内に入っているテストケースは全
て、デフォルトの <a class="reference internal" href="#id15">テストクライアント</a> にアクセスできます。このテストクライ
アントは <tt class="docutils literal"><span class="pre">self.client</span></tt> で参照できます。テストクライアントはテストごとに再
生成されるので、テスト間でクッキーのような状態情報が継承される心配はありま
せん。</p>
<p>例えば、以下のコード:</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">unittest</span>
<span class="kn">from</span> <span class="nn">django.test.client</span> <span class="kn">import</span> <span class="n">Client</span>

<span class="k">class</span> <span class="nc">SimpleTest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_details</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">()</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;/customer/details/&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failUnlessEqual</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">status_code</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">()</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;/customer/index/&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failUnlessEqual</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">status_code</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
</pre></div>
<p>では、各テストで <tt class="docutils literal"><span class="pre">Client</span></tt> をインスタンス化していますが、実際は次のコード
のように、 <tt class="docutils literal"><span class="pre">self.client</span></tt> を参照するだけでよいのです:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.test</span> <span class="kn">import</span> <span class="n">TestCase</span>

<span class="k">class</span> <span class="nc">SimpleTest</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_details</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;/customer/details/&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failUnlessEqual</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">status_code</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">test_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;/customer/index/&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failUnlessEqual</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">status_code</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="s-id24">
<span id="s-fixture-loading"></span><span id="s-topics-testing-fixtures"></span><h4>フィクスチャの読み込み<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h4>
<dl class="attribute">
<dt id="django.test.TestCase.fixtures">
<!--[django.test.TestCase.fixtures]--><tt class="descclassname">TestCase.</tt><tt class="descname">fixtures</tt><a class="headerlink" href="#django.test.TestCase.fixtures" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>データベースがバックにあるウェブサイトのテストで、データベース上に何もデー
タが入っていなければあまり意味はありません。データベースにテストデータを入
れやすくするために、 Django の独自 <tt class="docutils literal"><span class="pre">TestCase</span></tt> クラスは
<strong>フィクスチャ (fixture)</strong> の読み込み機能を提供しています。</p>
<p>フィクスチャとは、一群のデータを Django がデータベースに取り込める形式にし
たものです。例えば、ユーザアカウントを持つようなサイトを作っている場合、テ
スト中は仮のユーザアカウントの入ったフィクスチャを作り、データベースに入れ
ておくと便利です。</p>
<p>最も素直なフィクスチャの作成方法は、 <tt class="docutils literal"><span class="pre">manage.py</span> <span class="pre">dumpdata</span></tt> コマンドを使う
というものです。 <tt class="docutils literal"><span class="pre">dumpdata</span></tt> を使うにはデータベースに既に何らかのデータが
入っていなければなりません。詳しくは
<tt class="xref docutils literal"><span class="pre">dumpdata</span> <span class="pre">のドキュメント</span></tt> を参照してください。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><tt class="docutils literal"><span class="pre">manage.py</span> <span class="pre">syncdb</span></tt> を実行したことがあるなら、あなたの知らないうちにフィ
クスチャは使われています。最初に <tt class="docutils literal"><span class="pre">syncdb</span></tt> を実行したときに、 Django
は <tt class="docutils literal"><span class="pre">initial_data</span></tt> という名前のフィクスチャをインストールします。この
メカニズムを使えば、 (カテゴリのデフォルトセットのような) 新たなデータ
セットをデータベースに組み込めます。</p>
<p class="last"><tt class="docutils literal"><span class="pre">initial_data</span></tt> 以外の名前のフィクスチャは、
<tt class="docutils literal"><span class="pre">django-admin.py</span> <span class="pre">loaddata</span></tt> で手動で組み込めます。</p>
</div>
<p>単体テストでフィクスチャを使う場合、フィクスチャを作成して Django のプロジェ
クトディレクトリ下に置き、 <tt class="docutils literal"><span class="pre">dhango.test.TestCase</span></tt> のサブクラスの
<tt class="docutils literal"><span class="pre">fixtures</span></tt> クラス属性を指定します:</p>
<pre>from django.test import TestCase
from myapp.models import Animal

class AnimalTestCase(TestCase):
    fixtures = ['mammals.json', 'birds']

    def setUp(self):
        # 従来通りのテスト定義

    def testFluffyAnimals(self):
        # フィクスチャを使うテスト</pre>
<p>ユニットテストは、以下のように動作します:</p>
<ul class="simple">
<li>テストケースの開始時で、かつ <tt class="docutils literal"><span class="pre">setUp()</span></tt> の実行前に、 Django はデータベー
スを一掃して、データベースを <tt class="docutils literal"><span class="pre">syncdb</span></tt> 直後の状態に戻します。</li>
<li>次に、テストケースクラスに指定した全てのフィクスチャをインストールしま
す。上の例では、 <tt class="docutils literal"><span class="pre">mammals</span></tt> という名前の JSON フィクスチャと、
<tt class="docutils literal"><span class="pre">birds</span></tt> という名前のフィクスチャがインストールされます。フィクスチャ
の定義とインストールに関する詳細は
<tt class="xref docutils literal"><span class="pre">loaddata</span> <span class="pre">のドキュメント</span></tt>
を参照してください。</li>
</ul>
<p>このフラッシュ／ロードの作業はテストケースの実行毎に繰り返されるので、テス
トの結果が他のテストや以前に実行したテストの影響を受けたり、テストの順番に
左右されることはありません。</p>
</div>
<div class="section" id="s-urlconf">
<span id="s-urlconf-configuration"></span><h4>URLconf の設定<a class="headerlink" href="#urlconf" title="Permalink to this headline">¶</a></h4>
<div class="versionadded">
<span class="title">Django 1.0 で新たに登場しました.</span> </div>
<dl class="attribute">
<dt id="django.test.TestCase.urls">
<!--[django.test.TestCase.urls]--><tt class="descclassname">TestCase.</tt><tt class="descname">urls</tt><a class="headerlink" href="#django.test.TestCase.urls" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>アプリケーションでビューを定義している場合、テストクライアントを使ってビュー
を検査するテストを組み込みたいことがあるでしょう。しかし、エンドユーザはア
プリケーションのビューを自分の好きな URL でデプロイできるので、テストを行う
際には、ビューが特定の URL でアクセスできると期待してはなりません。</p>
<p>テスト用の URL 空間を指定するために、 <tt class="docutils literal"><span class="pre">django.test.TestCase</span></tt> はテストスイー
ト実行中に使われる URLconf をカスタマイズできる仕組みを提供しています。
<tt class="docutils literal"><span class="pre">TestCase</span></tt> インスタンスに <tt class="docutils literal"><span class="pre">urls</span></tt> 属性を指定しておくと、 <tt class="docutils literal"><span class="pre">TestCase</span></tt>
はその値をテスト実行中だけ <tt class="docutils literal"><span class="pre">ROOT_URLCONF</span></tt> に使います。</p>
<p>使い方を示しましょう:</p>
<pre>from django.test import TestCase

class TestMyViews(TestCase):
    urls = 'myapp.test_urls'

    def testIndexPageView(self):
        #  ``Client`` を使ってビューをテストする</pre>
<p>このテストケースは、ケースの実行中だけ、 <tt class="docutils literal"><span class="pre">myapp.test_urls</span></tt> を URLconf と
して使います。</p>
</div>
<div class="section" id="s-id25">
<span id="s-emptying-the-test-outbox"></span><span id="s-emptying-test-outbox"></span><h4>メール送信箱の内容抹消<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h4>
<div class="versionadded">
<span class="title">Django 1.0 で新たに登場しました.</span> </div>
<p>Django 独自の <tt class="docutils literal"><span class="pre">TestCase</span></tt> クラスを使うと、テストランナは各テストケースの開
始時にメールの送信箱に入っている内容を消去します。</p>
<p>テスト中のメールサービスの詳細は <a class="reference internal" href="#id27">メールサービス</a> を参照してください。</p>
</div>
<div class="section" id="s-id26">
<span id="s-assertions"></span><h4>アサーション<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h4>
<div class="versionadded">
<span class="title">Django 1.0 で新たに登場しました.</span> </div>
<p>通常の Python <tt class="docutils literal"><span class="pre">unittest.TestCase</span></tt> クラスが備えている <tt class="docutils literal"><span class="pre">assertTrue</span></tt> や
<tt class="docutils literal"><span class="pre">assertEquals</span></tt> のようなアサーションメソッドと同様、 Django 独自の
<tt class="docutils literal"><span class="pre">TestCase</span></tt> クラスでも Web アプリケーションをテストする上で便利な様々な
独自のアサーションメソッドを提供しています。</p>
<dl class="method">
<dt id="django.test.TestCase.assertContains">
<!--[django.test.TestCase.assertContains]--><tt class="descclassname">TestCase.</tt><tt class="descname">assertContains</tt>(<em>response</em>, <em>text</em>, <em>count=None</em>, <em>status_code=200</em>)<a class="headerlink" href="#django.test.TestCase.assertContains" title="Permalink to this definition">¶</a></dt>
<dd><tt class="docutils literal"><span class="pre">status_code</span></tt> に指定した状態コードで <tt class="docutils literal"><span class="pre">Response</span></tt> インスタンスが生成
され、レスポンスのコンテンツ内に <tt class="docutils literal"><span class="pre">text</span></tt> が入っているかどうか調べるア
サーションです。 <tt class="docutils literal"><span class="pre">count</span></tt> を指定すると、 <tt class="docutils literal"><span class="pre">text</span></tt> は正確に <tt class="docutils literal"><span class="pre">count</span></tt>
回出現せねばなりません。</dd></dl>

<dl class="method">
<dt id="django.test.TestCase.assertNotContains">
<!--[django.test.TestCase.assertNotContains]--><tt class="descclassname">TestCase.</tt><tt class="descname">assertNotContains</tt>(<em>response</em>, <em>text</em>, <em>status_code=200</em>)<a class="headerlink" href="#django.test.TestCase.assertNotContains" title="Permalink to this definition">¶</a></dt>
<dd><tt class="docutils literal"><span class="pre">status_code</span></tt> に指定した状態コードで <tt class="docutils literal"><span class="pre">Response</span></tt> インスタンスが生成
され、レスポンスのコンテンツ内に <tt class="docutils literal"><span class="pre">text</span></tt> が入っていないことを確認する
アサーションです。</dd></dl>

<dl class="method">
<dt id="django.test.assertFormError">
<!--[django.test.assertFormError]--><tt class="descname">assertFormError</tt>(<em>response</em>, <em>form</em>, <em>field</em>, <em>errors</em>)<a class="headerlink" href="#django.test.assertFormError" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">form</span></tt> に指定したフォーム上のフィールド <tt class="docutils literal"><span class="pre">field</span></tt> で、 <tt class="docutils literal"><span class="pre">errors</span></tt> に
指定したエラーリストと同じエラーが送出されるかどうか調べるアサーション
です。</p>
<p><tt class="docutils literal"><span class="pre">form</span></tt> はテンプレートコンテキスト上の <tt class="docutils literal"><span class="pre">Form</span></tt> インスタンスの名前です。</p>
<p><tt class="docutils literal"><span class="pre">field</span></tt> はフォーム内のフィールドの名前です。 <tt class="docutils literal"><span class="pre">field</span></tt> の値が
<tt class="xref docutils literal"><span class="pre">None</span></tt> であれば、非フィールドエラー (特定のフィールドに関連付けられて
いない、 <tt class="docutils literal"><span class="pre">form.non_field_errors()</span></tt> でアクセスできるエラー) がチェック
されます。</p>
<p><tt class="docutils literal"><span class="pre">errors</span></tt> はエラー文字列か、エラー文字列のリストです。フォームの検証結
果として返されるのと同じ形式です。</p>
</dd></dl>

<dl class="method">
<dt id="django.test.assertRedirects">
<!--[django.test.assertRedirects]--><tt class="descname">assertRedirects</tt>(<em>response</em>, <em>expected_url</em>, <em>status_code=302</em>, <em>target_status_code=200</em>)<a class="headerlink" href="#django.test.assertRedirects" title="Permalink to this definition">¶</a></dt>
<dd>レスポンスが <tt class="docutils literal"><span class="pre">status_code</span></tt> に指定したリダイレクト状態コードを持ち、か
つ <tt class="docutils literal"><span class="pre">expected_url</span></tt> へのリダイレクトを指示しており、さらにリダイレクト
先の内容を HTTP 状態コード <tt class="docutils literal"><span class="pre">target_status_code</span></tt> で取得できるかどうか
調べるアサーションです。</dd></dl>

<dl class="method">
<dt id="django.test.assertTemplateUsed">
<!--[django.test.assertTemplateUsed]--><tt class="descname">assertTemplateUsed</tt>(<em>response</em>, <em>template_name</em>)<a class="headerlink" href="#django.test.assertTemplateUsed" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">template_name</span></tt> に指定したテンプレートがレスポンスのレンダリングに使
われていることを確認するアサーションです。</p>
<p><tt class="docutils literal"><span class="pre">template_name</span></tt> は <tt class="docutils literal"><span class="pre">'admin/index.html'</span></tt> のような文字列です。</p>
</dd></dl>

<dl class="method">
<dt id="django.test.assertTemplateNotUsed">
<!--[django.test.assertTemplateNotUsed]--><tt class="descname">assertTemplateNotUsed</tt>(<em>response</em>, <em>template_name</em>)<a class="headerlink" href="#django.test.assertTemplateNotUsed" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">template_name</span></tt> に指定したテンプレートがレスポンスのレンダリングに使
われて <em>いない</em> ことを確認するアサーションです。</p>
<p><tt class="docutils literal"><span class="pre">template_name</span></tt> は <tt class="docutils literal"><span class="pre">'admin/index.html'</span></tt> のような文字列です。</p>
</dd></dl>

</div>
</div>
<div class="section" id="s-id27">
<span id="s-e-mail-services"></span><h3>メールサービス<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<span class="title">Django 1.0 で新たに登場しました.</span> </div>
<p>ビューが <a class="reference external" href="email.html#topics-email"><em>Django のメールサービス</em></a> を使っている場合、
ビューをテストするたびにメールが送信されてほしくはないでしょう。 Django の
テストランナは、テスト中に Django から送信されたすべてのメールをダミーの送
信箱に振り分けます。これによって、送信したメールの数から、各メールのメッセー
ジに至るまで、メール送信機能のすべてを (実際にメールを送らずに) テストでき
ます。</p>
<p>Django は、テストフレームワークを初期化する際、通常の
<a title="django.core.mail.SMTPConnection" class="reference external" href="email.html#django.core.mail.SMTPConnection"><tt class="xref docutils literal"><span class="pre">SMTPConnection</span></tt></a> クラスをダミーの SMTPConnection
実装に切替えます (Django の外部のメール送信機構、例えば Django を動かしてい
るホストで動いているメールサーバには一切影響を及ぼしません)。</p>
<dl class="data">
<dt id="django.core.mail.django.core.mail.output">
<!--[django.core.mail.django.core.mail.output]--><tt class="descclassname">django.core.mail.</tt><tt class="descname">output</tt><a class="headerlink" href="#django.core.mail.django.core.mail.output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>テストの実行中、 Django から送信されたメールは <tt class="docutils literal"><span class="pre">djnago.core.mail.outbox</span></tt>
に保存されます。 <tt class="docutils literal"><span class="pre">djnago.core.mail.outbox</span></tt> はその時点で送信された全ての
<tt class="xref docutils literal"><span class="pre">EmailMessage</span></tt> インスタンスからなるリストで、テ
スト時以外には存在しません。このダミー送信箱は、テストのセットアップ時に、
ダミーの <a title="django.core.mail.SMTPConnection" class="reference external" href="email.html#django.core.mail.SMTPConnection"><tt class="xref docutils literal"><span class="pre">SMTPConnection</span></tt></a> と組で初期化されます。テ
ストが終了すると、通常の <a title="django.core.mail.SMTPConnection" class="reference external" href="email.html#django.core.mail.SMTPConnection"><tt class="xref docutils literal"><span class="pre">SMTPConnection</span></tt></a> が復帰し、
ダミー送信箱は削除されます。</p>
<p><tt class="docutils literal"><span class="pre">django.core.mail.outbox</span></tt> を調べて、メール送信数やメールの内容をチェック
するコード例を以下に示します:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.core</span> <span class="kn">import</span> <span class="n">mail</span>
<span class="kn">from</span> <span class="nn">django.test</span> <span class="kn">import</span> <span class="n">TestCase</span>

<span class="k">class</span> <span class="nc">EmailTest</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">test_send_email</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Send message.</span>
        <span class="n">mail</span><span class="o">.</span><span class="n">send_mail</span><span class="p">(</span><span class="s">&#39;Subject here&#39;</span><span class="p">,</span> <span class="s">&#39;Here is the message.&#39;</span><span class="p">,</span>
            <span class="s">&#39;from@example.com&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;to@example.com&#39;</span><span class="p">],</span>
            <span class="n">fail_silently</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="c"># Test that one message has been sent.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mail</span><span class="o">.</span><span class="n">outbox</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c"># Verify that the subject of the first message is correct.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">mail</span><span class="o">.</span><span class="n">outbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">subject</span><span class="p">,</span> <span class="s">&#39;Subject here&#39;</span><span class="p">)</span>
</pre></div>
<p><a class="reference internal" href="#emptying-test-outbox"><em>前節で</em></a> 述べたように、テスト用の送信箱の内容は
TestCase 内の各テストケースの開始時点で抹消されます。手動で送信箱の内容を空
にしたければ、空のリストを <tt class="docutils literal"><span class="pre">mail.outbox</span></tt> に代入してください:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.core</span> <span class="kn">import</span> <span class="n">mail</span>

<span class="c"># Empty the test outbox</span>
<span class="n">mail</span><span class="o">.</span><span class="n">outbox</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
</div>
<div class="section" id="s-id28">
<span id="s-using-a-different-testing-framework"></span><h2>他のテストフレームワークを使う<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">doctest</span></tt> と <tt class="docutils literal"><span class="pre">unittest</span></tt> だけが Python のテストフレームワークではありま
せん。Django は他のテストフレームワークを明にサポートしているわけではありま
せんが、他のテストフレームワークで作成したテストを Django の通常のテストと
同じように呼び出すためのメカニズムは提供しています。</p>
<p><tt class="docutils literal"><span class="pre">./manage.py</span> <span class="pre">test</span></tt> を実行すると、 Django は <a class="reference external" href="../ref/settings.html#setting-TEST_RUNNER"><tt class="xref docutils literal"><span class="pre">TEST_RUNNER</span></tt></a> 設定を
探して、実行すべきテストランナを決定します。デフォルトでは、
<a class="reference external" href="../ref/settings.html#setting-TEST_RUNNER"><tt class="xref docutils literal"><span class="pre">TEST_RUNNER</span></tt></a> は <tt class="docutils literal"><span class="pre">django.test.simple.run_tests</span></tt> です。このメソッ
ドは Django のデフォルトのテスト動作を実装しており、以下のように動作します:</p>
<ol class="arabic simple">
<li>テスト前の全体的な準備を行います。</li>
<li>テストデータベースを生成します。</li>
<li><tt class="docutils literal"><span class="pre">syncdb</span></tt> を実行して、モデルと初期データをデータベースにインストールし
ます。</li>
<li>インストールされている全てのアプリケーションの <tt class="docutils literal"><span class="pre">models.py</span></tt> や
<tt class="docutils literal"><span class="pre">tests.py</span></tt> から、単体テストと doctest を探します。</li>
<li>見つかった単体テストと doctest を実行します。</li>
<li>テストデータベースを破壊します。</li>
<li>テスト後の全体的な後始末を行います。</li>
</ol>
<p>テストランナメソッドを自作して、そのメソッド名を <a class="reference external" href="../ref/settings.html#setting-TEST_RUNNER"><tt class="xref docutils literal"><span class="pre">TEST_RUNNER</span></tt></a> に
指定しておき、 <tt class="docutils literal"><span class="pre">./manage.py</span> <span class="pre">test</span></tt> を実行すると、 Django はそのテストラン
ナメソッドを実行します。これによって、 Python コードから任意のテストフレー
ムワークを実行できます。</p>
<div class="section" id="s-id29">
<span id="s-defining-a-test-runner"></span><h3>テストランナを定義する<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<span class="title">Django 1.0 で新たに登場しました.</span> </div>
<p>慣習的に、テストランナは <tt class="docutils literal"><span class="pre">run_tests</span></tt> と名付けます。テストランナは以下のよ
うに Django テストランナと同じ引数をとらねばなりません:</p>
<dl class="function">
<dt id="django.test.simple.run_tests">
<!--[django.test.simple.run_tests]--><tt class="descname">run_tests</tt>(<em>test_labels</em>, <em>verbosity=1</em>, <em>interactive=True</em>, <em>extra_tests=</em><span class="optional">[</span><span class="optional">]</span>)<a class="headerlink" href="#django.test.simple.run_tests" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<p><tt class="docutils literal"><span class="pre">test_labels</span></tt> には、実行したいテストを表す文字列 (ラベル) のリストを
指定します。ラベルは以下の 3 つの形式で指定できます:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">app.TestCase.test_method</span></tt> - テストケース中の個別のテストメソッ
ドを実行します。</li>
<li><tt class="docutils literal"><span class="pre">app.TestCase</span></tt> - テストケース中の全てのテストメソッドを実行しま
す。</li>
<li><tt class="docutils literal"><span class="pre">app</span></tt> - アプリケーション中の全てのテストを探して実行します。</li>
</ul>
<p><tt class="docutils literal"><span class="pre">test_labels</span></tt> が <tt class="xref docutils literal"><span class="pre">None</span></tt> の場合、テストランナは
<a class="reference external" href="../ref/settings.html#setting-INSTALLED_APPS"><tt class="xref docutils literal"><span class="pre">INSTALLED_APPS</span></tt></a> に登録されている全てのアプリケーションからテ
ストを探して実行します。</p>
<p><tt class="docutils literal"><span class="pre">verbosity</span></tt> には、コンソールに出力される通知情報やデバッグ情報の量を
指定します。  <tt class="docutils literal"><span class="pre">0</span></tt> にすると何も出力しません。 <tt class="docutils literal"><span class="pre">1</span></tt> は通常の出力、
<tt class="docutils literal"><span class="pre">2</span></tt> は多めの出力です。</p>
<p><tt class="docutils literal"><span class="pre">interactive</span></tt> を <tt class="xref docutils literal"><span class="pre">True</span></tt> にすると、テストスイートの実行時に、テスト
スイートからユーザに質問できるようになります。例えば、テストデータベー
スを削除してよいか尋ねるといった使い方です。 <tt class="docutils literal"><span class="pre">interactive</span></tt> を
<tt class="xref docutils literal"><span class="pre">False</span></tt> にする場合、テストスイートは手動操作なしで実行できねばなりま
せん。</p>
</blockquote>
<p><tt class="docutils literal"><span class="pre">extra_tests</span></tt> には、このテストランナに追加で実行させたい <tt class="docutils literal"><span class="pre">TestCase</span></tt>
インスタンスを指定します。 <tt class="docutils literal"><span class="pre">extra_tests</span></tt> を指定すると、 <tt class="docutils literal"><span class="pre">module_list</span></tt>
から発見したテストに加えて、指定したテストを実行します。</p>
<p>このメソッドは失敗したテストの数を返さねばなりません。</p>
</dd></dl>

</div>
<div class="section" id="s-module-django.test.utils">
<span id="s-testing-utilities"></span><h3>テスト用のユーティリティ<a class="headerlink" href="#module-django.test.utils" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">django.test.utils</span></tt> モジュールには、テストランナの自作に役立つユーティリ
ティメソッドが定義されています。</p>
<dl class="function">
<dt id="django.test.utils.setup_test_environment">
<!--[django.test.utils.setup_test_environment]--><tt class="descname">setup_test_environment</tt>()<a class="headerlink" href="#django.test.utils.setup_test_environment" title="Permalink to this definition">¶</a></dt>
<dd>テンプレートレンダリングシステム構成のインストールなど、テスト前の全
体的な準備を行い、ダミーの <tt class="docutils literal"><span class="pre">SMTPConnecton</span></tt> をセットアップします。</dd></dl>

<dl class="function">
<dt id="django.test.utils.teardown_test_environment">
<!--[django.test.utils.teardown_test_environment]--><tt class="descname">teardown_test_environment</tt>()<a class="headerlink" href="#django.test.utils.teardown_test_environment" title="Permalink to this definition">¶</a></dt>
<dd>テンプレートレンダリングシステムに組み込まれた黒魔術的なフックの除去な
ど、テスト後の全体的な後始末を行い、メールサービスを通常の状態に復帰し
ます。</dd></dl>

<p>データベースバックエンドの生成モジュール (<tt class="docutils literal"><span class="pre">connection.creation</span></tt>) にも、テ
スト時に便利なユーティリティがあります。</p>
<dl class="function">
<dt id="django.test.utils.create_test_db">
<!--[django.test.utils.create_test_db]--><tt class="descname">create_test_db</tt>(<em>verbosity=1</em>, <em>autoclobber=False</em>)<a class="headerlink" href="#django.test.utils.create_test_db" title="Permalink to this definition">¶</a></dt>
<dd><p>新たなテストデータベースを生成し、 <tt class="docutils literal"><span class="pre">syncdb</span></tt> を実行します。</p>
<p><tt class="docutils literal"><span class="pre">verbosity</span></tt> は <tt class="docutils literal"><span class="pre">run_tests()</span></tt> の同名の引数と同じ意味です。</p>
<p><tt class="docutils literal"><span class="pre">autoclobber</span></tt> には、テストデータベースと同名のデータベースが見つかっ
た際の挙動を指定します:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">autoclobber</span></tt> が <tt class="xref docutils literal"><span class="pre">False</span></tt> なら、既存のデータベースを破壊しても
よいかユーザに尋ねます。ユーザが「いいえ」を選択すると、その時点
で <tt class="docutils literal"><span class="pre">sys.exit</span></tt> を呼び出して終了します。</li>
<li><tt class="docutils literal"><span class="pre">autoclobber</span></tt> が <tt class="xref docutils literal"><span class="pre">True</span></tt> なら、既存のデータベースを破壊すると
きにユーザに了解を求めません。</li>
</ul>
<p>生成されたテストデータベースの名前を返します。</p>
<p><tt class="docutils literal"><span class="pre">create_test_db()</span></tt> には <tt class="docutils literal"><span class="pre">settings.DATABASE_NAME</span></tt> を変更してテストデー
タベースの名前にするという副作用があります。</p>
<div class="versionchanged">
<span class="title">Django 1.0 で変更されました:</span> <tt class="docutils literal"><span class="pre">create_test_db()</span></tt> 生成されたテストデータベースの名前を返すように
なりました。</div>
</dd></dl>

<dl class="function">
<dt id="django.test.utils.destroy_test_db">
<!--[django.test.utils.destroy_test_db]--><tt class="descname">destroy_test_db</tt>(<em>old_database_name</em>, <em>verbosity=1</em>)<a class="headerlink" href="#django.test.utils.destroy_test_db" title="Permalink to this definition">¶</a></dt>
<dd><p>このメソッドを呼び出した時点で <a class="reference external" href="../ref/settings.html#setting-DATABASE_NAME"><tt class="xref docutils literal"><span class="pre">DATABASE_NAME</span></tt></a> に設定されてい
るデータベースを破壊し、 <a class="reference external" href="../ref/settings.html#setting-DATABASE_NAME"><tt class="xref docutils literal"><span class="pre">DATABASE_NAME</span></tt></a> の値を
<tt class="docutils literal"><span class="pre">old_database_name</span></tt> に指定したデータベース名に戻します。</p>
<p><tt class="docutils literal"><span class="pre">verbosity</span></tt> は <tt class="docutils literal"><span class="pre">run_tests()</span></tt> の同名の引数と同じ意味です。</p>
</dd></dl>

</div>
</div>
</div>


          </div>         
        </div>
      </div>
      
        
          <div class="yui-b" id="sidebar">
            
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3>Table Of Contents</h3>
            <ul>
<li><a class="reference external" href="">Djangoアプリケーションのテスト</a><ul>
<li><a class="reference external" href="#id1">テストを書く</a><ul>
<li><a class="reference external" href="#doctest">doctest を書く</a></li>
<li><a class="reference external" href="#id4">ユニットテストを書く</a></li>
<li><a class="reference external" href="#id7">どちらのテストを使うべきか</a></li>
</ul>
</li>
<li><a class="reference external" href="#id9">テストを実行する</a><ul>
<li><a class="reference external" href="#id10">テストデータベース</a></li>
<li><a class="reference external" href="#id11">テストの出力を理解する</a></li>
<li><a class="reference external" href="#id12">その他のテスト条件</a></li>
<li><a class="reference external" href="#id13">テストプログラムの出力を理解する</a></li>
</ul>
</li>
<li><a class="reference external" href="#id14">テスト用のツール</a><ul>
<li><a class="reference external" href="#module-django.test.client">テストクライアント</a><ul>
<li><a class="reference external" href="#id16">テストの概要と簡単な例</a></li>
<li><a class="reference external" href="#id17">リクエスト生成</a></li>
<li><a class="reference external" href="#id18">レスポンスのテスト</a></li>
<li><a class="reference external" href="#id19">例外</a></li>
<li><a class="reference external" href="#id20">セッションの永続性</a></li>
<li><a class="reference external" href="#id21">ユニットテストの例</a></li>
</ul>
</li>
<li><a class="reference external" href="#id22">TestCaseクラス</a><ul>
<li><a class="reference external" href="#id23">デフォルトのテストクライアント</a></li>
<li><a class="reference external" href="#id24">フィクスチャの読み込み</a></li>
<li><a class="reference external" href="#urlconf">URLconf の設定</a></li>
<li><a class="reference external" href="#id25">メール送信箱の内容抹消</a></li>
<li><a class="reference external" href="#id26">アサーション</a></li>
</ul>
</li>
<li><a class="reference external" href="#id27">メールサービス</a></li>
</ul>
</li>
<li><a class="reference external" href="#id28">他のテストフレームワークを使う</a><ul>
<li><a class="reference external" href="#id29">テストランナを定義する</a></li>
<li><a class="reference external" href="#module-django.test.utils">テスト用のユーティリティ</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h3>前後のページ</h3>
  <ul>
    
      <li>前: <a href="files.html">ファイルの管理</a></li>
    
    
      <li>次: <a href="auth.html">Django でのユーザ認証</a></li>
    
  </ul>
  <h3>現在のページ:</h3>
  <ul>
      <li>
        <a href="../index.html">Django v1.0 documentation</a>
        
          <ul><li><a href="index.html">Django を使う</a>
        
        <ul><li>Djangoアプリケーションのテスト</li></ul>
        </li></ul>
      </li>
  </ul>  

            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/topics/testing.txt">Show Source</a></li>
            </ul>
            <h3>Quick search</h3>
            <form class="search" action="../search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
      </div>
              <h3>Last update:</h3>
              <p class="topless">Aug 31, 2012</p>
          </div> 
        
      
    </div>
    
    <div id="ft">
      <div class="nav">
    &laquo; <a href="files.html" title="ファイルの管理">前へ</a> 
     |
    <a href="index.html" title="Django を使う" accesskey="U">上へ</a>
   |
    <a href="auth.html" title="Django でのユーザ認証">次へ</a> &raquo;</div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>