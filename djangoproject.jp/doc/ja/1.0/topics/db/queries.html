<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>クエリを生成する &mdash; Django v1.0 documentation</title>
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../../',
          VERSION:     '1.0',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="contents" title="Global table of contents" href="../../contents.html" />
    <link rel="index" title="Global index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="top" title="Django v1.0 documentation" href="../../index.html" />
    <link rel="up" title="モデルとデータベース" href="index.html" />
    <link rel="next" title="マネジャ" href="managers.html" />
    <link rel="prev" title="モデルの作成" href="models.html" />
  </head>
  <body>
  <div id="custom-doc" class="yui-t6">
    <div id="hd">
      <h1><a href="../../index.html">Django v1.0 documentation</a></h1>
      <div id="global-nav">
        <a title="Home page" href="../../index.html">ホーム</a>  |
        <a title="Table of contents" href="../../contents.html">目次</a>  |
        <a title="Global index" href="../../genindex.html">索引</a>  |
        <a title="Search" href="../../modindex.html">モジュール一覧</a>
      </div>
      <div class="nav">
    &laquo; <a href="models.html" title="モデルの作成">前へ</a> 
     |
    <a href="../index.html" title="Django を使う" accesskey="U">上へ</a>
   |
    <a href="managers.html" title="マネジャ">次へ</a> &raquo;</div>
    </div>
    
    <div id="bd">
      <div id="yui-main">
        <div class="yui-b">
          <div class="yui-g" id="topics-db-queries">
            
  
  <div class="section" id="s-id1">
<span id="s-making-queries"></span><span id="s-topics-db-queries"></span><h1>クエリを生成する<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">revision-up-to:</th><td class="field-body">8961 (1.0)</td>
</tr>
</tbody>
</table>
<p><a class="reference external" href="models.html#topics-db-models"><em>データモデル</em></a> を作成したら、次はデータベースからデー
タを取り出す必要があります。このドキュメントでは、モデルから利用できるデー
タベース抽象化 API と、オブジェクトを生成、取得、更新する方法について説明し
ます。モデルの照合オプションの詳細は
<a class="reference external" href="../../ref/models/index.html#ref-models-index"><em>データモデルリファレンス</em></a> を参照してください。</p>
<p>このリファレンスでは、以下のような Poll アプリケーションを参考に話を進めま
す:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Blog</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">tagline</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__unicode__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

<span class="k">class</span> <span class="nc">Author</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">EmailField</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__unicode__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

<span class="k">class</span> <span class="nc">Entry</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">blog</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Blog</span><span class="p">)</span>
    <span class="n">headline</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span>
    <span class="n">body_text</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>
    <span class="n">pub_date</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">DateTimeField</span><span class="p">()</span>
    <span class="n">authors</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Author</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__unicode__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">headline</span>
</pre></div>
<div class="section" id="s-id2">
<span id="s-creating-objects"></span><h2>オブジェクトの生成<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>Django では、データベーステーブル上のデータを Python オブジェクトで表現する
ために、モデルクラスがデータベーステーブルを表現し、クラスのインスタンスが
テーブル上のレコードを表現するという直感的なシステムを使っています。</p>
<p>オブジェクトを生成するには、キーワード引数を使ってモデルクラスのインスタン
スを生成し、 <tt class="docutils literal"><span class="pre">save()</span></tt> メソッドを呼び出してデータベースに保存します。</p>
<p>モデルクラスは Python パス上のどこからでも import でき、期待通りに動作しま
す (わざわざこのような説明をするのは、以前のバージョンの Django ではモデル
の import 方法がかなり風変わりだったからです)。</p>
<p>モデルが <tt class="docutils literal"><span class="pre">mysite/blog/models.py</span></tt> というファイルで定義されているとすると、
オブジェクトの作成は以下の例のようになります:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mysite.blog.models</span> <span class="kn">import</span> <span class="n">Blog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;Beatles Blog&#39;</span><span class="p">,</span> <span class="n">tagline</span><span class="o">=</span><span class="s">&#39;All the latest Beatles news.&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
<p>この操作によって、背後では <tt class="docutils literal"><span class="pre">INSERT</span></tt> SQL 文が実行されます。 Django はユー
ザが明示的に <tt class="docutils literal"><span class="pre">save()</span></tt> を呼び出すまでデータベースを操作しません。</p>
<p><tt class="docutils literal"><span class="pre">save()</span></tt> メソッドには戻り値がありません。</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p><tt class="docutils literal"><span class="pre">save()</span></tt> には高度な使い方のためのオプションがありますが、ここでは解説
しません。詳しくは <tt class="docutils literal"><span class="pre">save()</span></tt> のドキュメントを参照してください。</p>
<p class="last">ワンステップでオブジェクトを生成して保存するには <tt class="docutils literal"><span class="pre">create</span></tt> メソッドを</p>
</div>
</div>
<div class="section" id="s-id3">
<span id="s-saving-changes-to-objects"></span><h2>オブジェクトへの変更を保存する<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>すでにデータベース上にあるオブジェクトへの変更を保存するには <tt class="docutils literal"><span class="pre">save()</span></tt> を
使います。</p>
<p><tt class="docutils literal"><span class="pre">Blog</span></tt> インスタンス <tt class="docutils literal"><span class="pre">b5</span></tt> がすでにデータベース上にあるとすると、以下の例
は <tt class="docutils literal"><span class="pre">b5</span></tt> の名前を変更して、データベース上のレコードを更新します:</p>
<pre>&gt;&gt; b5.name = 'New name'
&gt;&gt; b5.save()</pre>
<p>この例では、背後で <tt class="docutils literal"><span class="pre">UPDATE</span></tt> SQL 文が実行されています。 Django は明示的に
<tt class="docutils literal"><span class="pre">save()</span></tt> を呼び出すまでデータベースを操作しません。</p>
<div class="section" id="s-foreignkey-manytomanyfield">
<span id="s-saving-foreignkey-and-manytomanyfield-fields"></span><h3><tt class="docutils literal"><span class="pre">ForeignKey</span></tt> や <tt class="docutils literal"><span class="pre">ManyToManyField</span></tt> の保存<a class="headerlink" href="#foreignkey-manytomanyfield" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">ForeignKey</span></tt> フィールドの更新は、通常のフィールドへの変更と同じです。すな
わち、適切な型のオブジェクトを代入して保存すると、フィールドの値を更新でき
ます:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cheese_blog</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;Cheddar Talk&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span><span class="o">.</span><span class="n">blog</span> <span class="o">=</span> <span class="n">cheese_blog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entry</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">ManyToManyField</span></tt> の更新は少し違います。リレーションにレコードを一つ追加
したい場合は <tt class="docutils literal"><span class="pre">add()</span></tt> メソッドを使います:</p>
<pre>&gt;&gt; joe = Author.objects.create(name="Joe")
&gt;&gt; entry.authors.add(joe)</pre>
<p>間違った型のオブジェクトを外部キーに代入したり <tt class="docutils literal"><span class="pre">add()</span></tt> したりすると
Django はエラーを出します。</p>
</div>
</div>
<div class="section" id="s-id4">
<span id="s-retrieving-objects"></span><h2>オブジェクトの取得<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>オブジェクトをデータベースから取得するには、モデルクラスのマネジャ
(<tt class="docutils literal"><span class="pre">Manager</span></tt>) を介してクエリセット (<tt class="docutils literal"><span class="pre">QuerySet</span></tt>) を構築します。</p>
<p>クエリセットはデータベース上にあるオブジェクトの集まりを表現しています。
クエリセットには、集合を指定パラメタに従って絞り込むための条件である
<em>フィルタ (filter)</em> を複数個持たせられます。 SQL 用語でいえば、クエリセット
は <tt class="docutils literal"><span class="pre">SELECT</span></tt> 文であり、フィルタは <tt class="docutils literal"><span class="pre">WHERE</span></tt> や <tt class="docutils literal"><span class="pre">LIMIT</span></tt> のような限定節に
あたります。</p>
<p>クエリセットはモデルのマネジャから取得します。モデルには最低一つの
マネジャがあり、デフォルトでは <tt class="docutils literal"><span class="pre">objects</span></tt> という名前がついています。
マネジャにはモデルクラスから直接アクセスしてください:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span>
<span class="go">&lt;django.db.models.manager.Manager object at ...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;Foo&#39;</span><span class="p">,</span> <span class="n">tagline</span><span class="o">=</span><span class="s">&#39;Bar&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">objects</span>
<span class="go">Traceback:</span>
<span class="go">    ...</span>
<span class="go">AttributeError: &quot;Manager isn&#39;t accessible via Blog instances.&quot;</span>
</pre></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">(「テーブルレベル」の操作と「レコードレベル」の操作を分離させるため、マ
ネジャはモデルのインスタンスではなくモデルクラスだけからアクセスできる
ようになっています。)</p>
</div>
<p>モデル内でのクエリセットの主なソースはマネジャです。マネジャは、データベー
スオブジェクト上の全てのオブジェクトを表す「ルートの」クエリセットであるか
のように振舞います。例えば、初期クエリセットである <tt class="docutils literal"><span class="pre">Blog.objects</span></tt> には、
データベース上の全ての <tt class="docutils literal"><span class="pre">Blog</span></tt> オブジェクトが入っています。</p>
<div class="section" id="s-id5">
<span id="s-retrieving-all-objects"></span><h3>全てのオブジェクトの取得<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>テーブルからオブジェクトを取得する最も単純な方法は全てのオブジェクトを取得
するというものです。全オブジェクトを取得するには、マネジャの <tt class="docutils literal"><span class="pre">all()</span></tt> メソッ
ドを使って下さい:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">all_entries</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">all()</span></tt> メソッドはデータベース上の全てのオブジェクトを表現するクエリセッ
トを返します。</p>
<p>(<tt class="docutils literal"><span class="pre">Entry.objects</span></tt> がクエリセットを返すというのなら、なぜ単に
<tt class="docutils literal"><span class="pre">Entry.objects</span></tt> と書かないのでしょうか？それは、ルートのクエリセットであ
る <tt class="docutils literal"><span class="pre">Entry.objects</span></tt> が特別扱いされていて、値評価できないようになっているか
らです。 <tt class="docutils literal"><span class="pre">all()</span></tt> メソッドは、値評価 <em>できる</em> クエリセットを返します。</p>
</div>
<div class="section" id="s-id6">
<span id="s-retrieving-specific-objects-with-filters"></span><h3>フィルタを使ってオブジェクトを取り出す<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>マネジャによって提供される、いわゆるルートクエリセットを使えば、データベー
ステーブル上の全てのオブジェクトを表せます。とはいえ、通常は全オブジェクト
の集合からサブセットだけを取り出したいことでしょう。</p>
<p>サブセットを作成するには、フィルタ条件を追加して、初期クエリセットをリファ
インする必要があります。クエリセットの洗練には、主に二つの方法があります:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">filter(**kwargs)</span></tt></dt>
<dd>指定した照合パラメタに一致するオブジェクトの集合を表現する、新たな
クエリセットを返します。</dd>
<dt><tt class="docutils literal"><span class="pre">exclude(**kwargs)</span></tt></dt>
<dd>指定した照合パラメタに一致 <em>しない</em> オブジェクトの集合を表現する、
新たなクエリセットを返します。</dd>
</dl>
<p>照合パラメタ (上の関数定義における <tt class="docutils literal"><span class="pre">**kwargs</span></tt>) は、後述の
<a class="reference internal" href="#id16">フィールドの照合</a> で解説するフォーマットにせねばなりません。</p>
<p>例えば、 2006 年のブログエントリを表すクエリセットを取得するには、以下のよ
うに <tt class="docutils literal"><span class="pre">filter()</span></tt> を使います:</p>
<div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2006</span><span class="p">)</span>
</pre></div>
<p>(<tt class="docutils literal"><span class="pre">Entry.objects.all().filter(...)</span></tt> のように、 <tt class="docutils literal"><span class="pre">all()</span></tt> を使わなくてもよ
いことに注意して下さい。 <tt class="docutils literal"><span class="pre">all()</span></tt> を使っても問題なく動作しますが、
<tt class="docutils literal"><span class="pre">all()</span></tt> が必要となるのはルートクエリセットから全てのオブジェクトを取り出
したい場合だけです。)</p>
<div class="section" id="s-id8">
<span id="s-id7"></span><span id="s-chaining-filters"></span><h4>フィルタの連鎖<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>クエリセットをリファインした結果は、それ自体クエリセットになります。従って、
リファイン操作は連鎖させられます。例えば:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">headline__startswith</span><span class="o">=</span><span class="s">&#39;What&#39;</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">pub_date__gte</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">pub_date__gte</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
<p>この例では、データベースの全てのエントリを表す初期クエリセットに対し、
<tt class="docutils literal"><span class="pre">filter()</span></tt> をかけた後に <tt class="docutils literal"><span class="pre">exclude()</span></tt> を実行し、さらにもう一つ
<tt class="docutils literal"><span class="pre">filter()</span></tt> をかけています。最終的に得られるのは、 &quot;What&quot; で始まるヘッドラ
インのうち、 January 1, 2005 から今日までの間に公開されたエントリです。</p>
</div>
<div class="section" id="s-id10">
<span id="s-id9"></span><span id="s-filtered-querysets-are-unique"></span><h4>フィルタしたクエリセットは一意なオブジェクトである<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p>クエリセットのリファインを行うと、その都度新たなクエリセットを得ます。新た
なクエリセットは以前のクエリセットになんら縛られていません。リファイン操作
のたびに、別個の独立したクエリセットが作成され、個別に保存したり、再利用し
たりできます。</p>
<p>例えば:</p>
<pre>&gt;&gt; q1 = Entry.objects.filter(headline__startswith="What")
&gt;&gt; q2 = q1.exclude(pub_date__gte=datetime.now())
&gt;&gt; q3 = q1.filter(pub_date__gte=datetime.now())</pre>
<p>これら 3 つのクエリセットは別個のものです。最初はヘッドラインが &quot;What&quot; で始
まる全てのエントリの入ったベースのクエリセットです。二つ目のクエリセットは、
最初のクエリセットのサブセットであり、 <tt class="docutils literal"><span class="pre">pub_date</span></tt> の値が現在時刻よりも大
きいものを排除します。三つ目のクエリセットも最初のクエリセットのサブセット
で、 <tt class="docutils literal"><span class="pre">pub_date</span></tt> の値が現在時刻よりも大きいものだけを選択するようになって
います。こうしたリファイン操作は、初期クエリセット (<tt class="docutils literal"><span class="pre">q1</span></tt>) に影響を及ぼし
ません。</p>
</div>
<div class="section" id="s-id12">
<span id="s-id11"></span><span id="s-querysets-are-lazy"></span><h4>クエリセットは遅延評価される<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<p>クエリセットの評価は遅延型 (lazy) です。すなわち、クエリセットの作成自体は
データベース操作を引き起こしません。クエリセットは <em>評価される</em> までデータ
ベースへのクエリを実行しないので、延々フィルタを重ねられます:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__startswith</span><span class="o">=</span><span class="s">&quot;What&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__lte</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">exclude</span><span class="p">(</span><span class="n">body_text__icontains</span><span class="o">=</span><span class="s">&quot;food&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">q</span>
</pre></div>
<p>この例では、データベースに 3 度アクセスするように見えますが、実際には一度だ
け、最後の行のとき (<tt class="docutils literal"><span class="pre">print</span> <span class="pre">q</span></tt>) しかアクセスしません。一般に、
<tt class="docutils literal"><span class="pre">QuerySet</span></tt> の結果は、その内容を「調べる」まで、データベースから取り出され
ません。 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> は、クエリの内容を調べたときにはじめて <em>値評価</em> され
るのです。値評価がいつ行われているかは、
<a class="reference external" href="../../ref/models/querysets.html#when-querysets-are-evaluated"><em>クエリセットはいつ評価されるのか</em></a> で詳しく説明しています。</p>
</div>
<div class="section" id="s-id13">
<h4>その他のクエリセットメソッド<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<p>ほとんどの場合、データベース上のオブジェクトを照合するには、 <tt class="docutils literal"><span class="pre">all()</span></tt>,
<tt class="docutils literal"><span class="pre">filter()</span></tt>, <tt class="docutils literal"><span class="pre">exclude()</span></tt> メソッドで事足ります。とはいえ、クエリセットが
サポートしているメソッドはもっとたくさんあります。クエリセットメソッドの詳
細な説明は、 <a class="reference external" href="../../ref/models/querysets.html#id3"><em>クエリセット API リファレンス</em></a> を参照して
ください。</p>
</div>
</div>
<div class="section" id="s-id15">
<span id="s-id14"></span><span id="s-limiting-querysets"></span><h3>クエリセットに制約を課す<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p>クエリセットの返す結果を特定の個数に制限したい場合には、 Python の配列スラ
イス表記を使います。これは SQL の <tt class="docutils literal"><span class="pre">LIMIT</span></tt> 節や <tt class="docutils literal"><span class="pre">OFFSET</span></tt> 節と等価です。</p>
<p>以下の例は、最初の 5 オブジェクトだけを返します (<tt class="docutils literal"><span class="pre">LIMIT</span> <span class="pre">5</span></tt> に相当します):</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
<p>以下の例は、 6 番目から 10 番目までのオブジェクトを返します
(<tt class="docutils literal"><span class="pre">OFFSET</span> <span class="pre">5</span> <span class="pre">LIMIT</span> <span class="pre">5</span></tt> に相当します):</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[</span><span class="mi">5</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
</pre></div>
<p>一般に、クエリセットをスライスしてもクエリセットを新たに生成して返すだけで、
クエリの評価は行いません。例外はスライス表記に「ステップ (step)」パラメタを
使ったときです。以下の例では、クエリを実際に実行し、最初の 10 オブジェクト
中から 1 つおきにオブジェクトを取り出したリストを返します:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()[:</span><span class="mi">10</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
<p>リストではなく <em>単一の</em> オブジェクトを取得したい場合
(<tt class="docutils literal"><span class="pre">SELECT</span> <span class="pre">foo</span> <span class="pre">FROM</span> <span class="pre">bar</span> <span class="pre">LIMIT</span> <span class="pre">1</span></tt> のような場合) には、スライスではなく単純な
インデクス指定を行います。以下の例はデータベースのエントリをヘッドラインに
ついてアルファベット順に整列した後、最初の <tt class="docutils literal"><span class="pre">Entry</span></tt> を取得して返します:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;headline&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
<p>これはだいたい以下と同じになります:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s">&#39;headline&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
<p>ただし、指定条件にマッチするオブジェクトがない場合、前者は <tt class="docutils literal"><span class="pre">IndexError</span></tt>,
後者は <tt class="docutils literal"><span class="pre">DoesNotExist</span></tt> を送出します。詳しくは <tt class="docutils literal"><span class="pre">get()</span></tt> のドキュメントを参
照してください。</p>
</div>
<div class="section" id="s-id16">
<span id="s-field-lookups"></span><span id="s-field-lookups-intro"></span><h3>フィールドの照合<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<p>フィールドの照合操作によって、 SQL の <tt class="docutils literal"><span class="pre">WHERE</span></tt> 節の中身が決まります。フィー
ルドの照合を行うには、 <tt class="docutils literal"><span class="pre">filter()</span></tt>, <tt class="docutils literal"><span class="pre">exclude()</span></tt> および <tt class="docutils literal"><span class="pre">get()</span></tt> といっ
たクエリセットのメソッドのキーワード引数を指定します。</p>
<p>基本的に、照合のキーワード引数名は  <tt class="docutils literal"><span class="pre">field__lookuptype=value</span></tt> のような形
式をとります (アンダースコアは二重です)。例えば:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__lte</span><span class="o">=</span><span class="s">&#39;2006-01-01&#39;</span><span class="p">)</span>
</pre></div>
<p>は、(大雑把にいって) 以下のような SQL 文に変換されます:</p>
<pre>SELECT * FROM blog_entry WHERE pub_date &lt;= '2006-01-01';</pre>
<div class="admonition-how-this-is-possible admonition">
<p class="first admonition-title">How this is possible</p>
<p class="last">Python には、任意の名前と値をもった引数を受け取れる関数を定義する機能が
あり、引数名とその値は実行時に評価されます。くわしい情報は公式の Python
チュートリアルの <a class="reference external" href="http://www.python.jp/doc/release/tut/node6.html#SECTION006720000000000000000">キーワード引数</a> を参照してください。</p>
</div>
<p>照合時に無効なキーワード引数が渡されると、 <tt class="docutils literal"><span class="pre">TypeError</span></tt> が送出されます。</p>
<p>データベース API は 2 ダース近くの照合タイプをサポートしています。詳しいリ
ファレンスは <a class="reference external" href="../../ref/models/querysets.html#field-lookups"><em>フィールド照合リファレンス</em></a> を参照してく
ださい。ここでは、よく使う照合タイプをいくつか示します:</p>
<dl class="docutils">
<dt><tt class="xref docutils literal"><span class="pre">exact</span></tt></dt>
<dd><p class="first">「厳密一致」です。例えば:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">headline__exact</span><span class="o">=</span><span class="s">&quot;Man bites dog&quot;</span><span class="p">)</span>
</pre></div>
<p>は、以下のような SQL を生成します:</p>
<div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">headline</span> <span class="o">=</span> <span class="s1">&#39;Man bits dog&#39;</span><span class="p">;</span>
</pre></div>
<p>照合タイプを指定しなかった場合、つまり二重アンダースコアの入ったキー
ワード引数を使わないかぎり、照合条件は <tt class="docutils literal"><span class="pre">exact</span></tt> とみなされます。</p>
<p>例えば、以下の二つの文は同じ意味です:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">id__exact</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>  <span class="c"># Explicit form</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>         <span class="c"># __exact is implied</span>
</pre></div>
<p class="last"><tt class="docutils literal"><span class="pre">exact</span></tt> はよく使われるため、便宜的にこのような仕様にしています。</p>
</dd>
<dt><tt class="xref docutils literal"><span class="pre">iexact</span></tt></dt>
<dd><p class="first">大小文字を区別しない一致です。以下のクエリ:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name__iexact</span><span class="o">=</span><span class="s">&quot;beatles blog&quot;</span><span class="p">)</span>
</pre></div>
<p class="last">は、 &quot;Beatles Blog&quot;, &quot;beatles blog&quot;, &quot;BeAtlES blOG&quot; といったタイト
ルの <tt class="docutils literal"><span class="pre">Blog</span></tt> オブジェクトにマッチします。</p>
</dd>
<dt><tt class="xref docutils literal"><span class="pre">contains</span></tt></dt>
<dd><p class="first">大小文字を区別する部分一致テストです。以下のクエリ:</p>
<div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span>
</pre></div>
<p>は、おおざっぱにいって以下の SQL に変換されます:</p>
<div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">headline</span> <span class="k">LIKE</span> <span class="s1">&#39;%Lennon%&#39;</span><span class="p">;</span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">'Today</span> <span class="pre">Lennon</span> <span class="pre">honored'</span></tt> には一致しますが、
<tt class="docutils literal"><span class="pre">'today</span> <span class="pre">lennon</span> <span class="pre">honored'</span></tt> には一致しないので注意してください。</p>
<p class="last">大小文字を区別しない <tt class="xref docutils literal"><span class="pre">icontains</span></tt> もあります。</p>
</dd>
<dt><tt class="xref docutils literal"><span class="pre">startswith</span></tt>, <tt class="xref docutils literal"><span class="pre">endswith</span></tt></dt>
<dd>それぞれ、前方一致と後方一致です。大小文字を区別しない
<tt class="xref docutils literal"><span class="pre">istartswith</span></tt> や <tt class="xref docutils literal"><span class="pre">iendswith</span></tt> もあります。</dd>
</dl>
<p>ここに挙げたのはほんの一部です。全ての照合タイプの解説は
<a class="reference external" href="../../ref/models/querysets.html#field-lookups"><em>フィールド照合タイプのリファレンス</em></a> を参照してくださ
い。</p>
</div>
<div class="section" id="s-id18">
<span id="s-lookups-that-span-relationships"></span><h3>リレーションをまたいだ照合<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<p>Django では、背後で自動的に SQL <tt class="docutils literal"><span class="pre">JOIN</span></tt> を処理し、照合の際にリレーションを
「追跡」する、強力でありながら直感的な手段を提供しています。リレーションを
またぐには、二重アンダースコアを使ってリレーションの張られたフィールドのフィー
ルド名を指定します。リレーション間のスパンは、目的のフィールドに到達するま
でいくらでも連鎖させられます。</p>
<p>以下の例では、 <tt class="docutils literal"><span class="pre">name</span></tt> が <tt class="docutils literal"><span class="pre">'Beatles</span> <span class="pre">Blog'</span></tt> であるような <tt class="docutils literal"><span class="pre">Blog</span></tt> の
<tt class="docutils literal"><span class="pre">Entry</span></tt> エントリオブジェクト全てを取得します:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__name__exact</span><span class="o">=</span><span class="s">&#39;Beatles Blog&#39;</span><span class="p">)</span>
</pre></div>
<p>スパンは好きなだけ深く張れます。</p>
<p>リレーションのスパンは逆方向にも張れます。「逆方向の」リレーションを参照す
るには、モデル名を小文字にした名前を使います。</p>
<p>以下の例では、 <tt class="docutils literal"><span class="pre">headline</span></tt> に <tt class="docutils literal"><span class="pre">'Lennon'</span></tt> を含むような <tt class="docutils literal"><span class="pre">Entry</span></tt> を少なく
とも一つ持つような全ての <tt class="docutils literal"><span class="pre">Blog</span></tt> オブジェクトを取得します:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__headline__contains</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span>
</pre></div>
<p>複数のリレーションをまたいでフィルタを行っていて、中間のモデルにフィルタ条
件に合致する値が存在しないと、 Django はその値が空である (<tt class="docutils literal"><span class="pre">NULL</span></tt> が入って
いる) だけの有意なオブジェクトとして扱います。つまり、エラーを送出しません。
例えば、以下のフィルタを考えましょう:</p>
<div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__author__name</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span>
</pre></div>
<p>(<tt class="docutils literal"><span class="pre">Author</span></tt> モデルは存在するものとします) <tt class="docutils literal"><span class="pre">entry</span></tt> の <tt class="docutils literal"><span class="pre">author</span></tt> を空にし
ていると、 Django は <tt class="docutils literal"><span class="pre">author</span></tt> が存在しないために <tt class="docutils literal"><span class="pre">name</span></tt> を辿れませんが、
エラーは送出せず、あたかも <tt class="docutils literal"><span class="pre">name</span></tt> も空であるかのように扱います。たいてい
は、この仕様で期待通りに動きますが、 <tt class="docutils literal"><span class="pre">isnull</span></tt> を使うと、少し混乱をきたし
ます。すなわち:</p>
<div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__author__name__isnull</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
<p>は、 <tt class="docutils literal"><span class="pre">author</span></tt> の <tt class="docutils literal"><span class="pre">name</span></tt> が空の <tt class="docutils literal"><span class="pre">Blog</span></tt> だけでなく、 <tt class="docutils literal"><span class="pre">entry</span></tt> の
<tt class="docutils literal"><span class="pre">author</span></tt> が空の <tt class="docutils literal"><span class="pre">Blog</span></tt> も返してしまうのです。後者のオブジェクトを返して
欲しくないのなら、以下のように書いてください:</p>
<div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objetcs</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__author__isnull</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
        <span class="n">entry__author__name__isnull</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
<div class="section" id="s-id19">
<span id="s-spanning-multi-valued-relationships"></span><h4>多値のリレーションをスパンする<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h4>
<div class="versionadded">
<span class="title">Django 1.0 で新たに登場しました.</span> </div>
<p><tt class="docutils literal"><span class="pre">ManyToManyField</span></tt> や <tt class="docutils literal"><span class="pre">ForeignKey</span></tt> の逆リレーションを使ってフィルタを行
う場合、 2 種類の異なるフィルタ方法があります。 <tt class="docutils literal"><span class="pre">Blog</span></tt> / <tt class="docutils literal"><span class="pre">Entry</span></tt> のリレー
ション (<tt class="docutils literal"><span class="pre">Blog</span></tt> から <tt class="docutils literal"><span class="pre">Entry</span></tt> が 1 対多であるようなリレーション) を考えて
みましょう。このようなモデルでは、例えばヘッドラインに <em>'Lennon'</em> を含み、
<strong>かつ</strong> 2008 年に公開されたエントリを持つようなブログを検索したい場合があ
るでしょう。あるいは、ヘッドラインに <em>'Lennon'</em> を含むか、 <strong>あるいは</strong>
2008 年に公開されたエントリを含むようなブログの検索もあり得ます。複数のエン
トリが一つの <tt class="docutils literal"><span class="pre">Blog</span></tt> に関連付けられているので、いずれのクエリも実行可能で
すし、意味をなす場合があるでしょう。</p>
<p><tt class="docutils literal"><span class="pre">ManyToManyField</span></tt> を使っている場合にも、同じような状況が起こります。例え
ば、 <tt class="docutils literal"><span class="pre">Entry</span></tt> に <tt class="docutils literal"><span class="pre">tags</span></tt> という名前の <tt class="docutils literal"><span class="pre">ManyToManyField</span></tt> があり、
<em>'music'</em> や <em>'band'</em> というタグに関連付けられたエントリを検索したい場合や、
<em>'music'</em> タグのついた <em>'public'</em> 状態のエントリを取り出したい場合があるで
しょう。</p>
<p>こうした状況をうまく扱うために、 Django には <tt class="docutils literal"><span class="pre">filter()</span></tt> および
<tt class="docutils literal"><span class="pre">exclude()</span></tt> といった呼び出しがあります。 <tt class="docutils literal"><span class="pre">filter()</span></tt> に指定した条件は同
時に適用され、条件全てに一致する要素をフィルタします。 <tt class="docutils literal"><span class="pre">filter()</span></tt> を連続
して呼び出すと、通常はオブジェクトの集合により狭い制約をかけますが、多値リ
レーションの場合、新たな制約は、前の <tt class="docutils literal"><span class="pre">filter()</span></tt> で絞り込んだリレーション
先をさらに絞り込むのではなく、前の <tt class="docutils literal"><span class="pre">filter()</span></tt> で絞り込んだリレーション先
にリンクしているリレーション元からリレーションを張られている全てのオブジェ
クトに対して適用されてしまいます。</p>
<p>この話はちょっとややこしいので、例を挙げて解説しましょう。 <em>'Lennon'</em> をヘッ
ドラインに含み、 2008 年に公開されたエントリを含むブログを選択するには、以
下のように書きます:</p>
<div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__headline__contains</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">,</span>
        <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">)</span>
</pre></div>
<p>一方、 <em>'Lennon'</em> をヘッドラインに含むか、 <strong>あるいは</strong> 2008 年に公開された
エンリを含むブログを検索するには、以下のように書きます:</p>
<div class="highlight"><pre><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry__headline__contains</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="n">entry__pub_date__year</span><span class="o">=</span><span class="mi">2008</span><span class="p">)</span>
</pre></div>
<p>後者の例では、最初の <tt class="docutils literal"><span class="pre">filter()</span></tt> でクエリセットに制約をかけ、特定のエント
リにリンクを持つブログだけを取り出しています。次の <tt class="docutils literal"><span class="pre">filter()</span></tt> では、取り
出した <tt class="docutils literal"><span class="pre">Blog</span></tt> オブジェクトから、 <em>さらに</em> 二つ目の条件に合うものに制約を
かけています。従って、二つ目の <tt class="docutils literal"><span class="pre">filter()</span></tt> で制約をかけている対象の
<tt class="docutils literal"><span class="pre">entry</span></tt> は、最初のフィルタで絞り込んだエントリと同じときもあれば、違うと
きもあります。一つめの <tt class="docutils literal"><span class="pre">filter()</span></tt> でフィルタしているのはあくまでも
<tt class="docutils literal"><span class="pre">Blog</span></tt> であって、 <tt class="docutils literal"><span class="pre">Entry</span></tt> ではないからです。</p>
<p>この挙動は、 <tt class="docutils literal"><span class="pre">exclude()</span></tt> にもあてはまります。一つの <tt class="docutils literal"><span class="pre">exclude()</span></tt> に指定
した条件は、 (多値リレーションの場合は) 各インスタンスに同時に適用されます。
<tt class="docutils literal"><span class="pre">filter()</span></tt> や <tt class="docutils literal"><span class="pre">exclude()</span></tt> を連続して呼び出すと、毎回違うリンク先集合を
使ってフィルタを行ってしまう可能性があるのです。</p>
</div>
</div>
<div class="section" id="s-pk">
<span id="s-the-pk-lookup-shortcut"></span><h3>pk 照合ショートカット<a class="headerlink" href="#pk" title="Permalink to this headline">¶</a></h3>
<p>利便性のために、 Django には <tt class="docutils literal"><span class="pre">pk</span></tt> という照合形式があります。 <tt class="docutils literal"><span class="pre">pk</span></tt> は
<tt class="docutils literal"><span class="pre">primary_key</span></tt> を表します。</p>
<p><tt class="docutils literal"><span class="pre">Blog</span></tt> モデルの例では、主キーは <tt class="docutils literal"><span class="pre">id</span></tt> フィールドなので、以下の二つの文は
等価です:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">id__exact</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span> <span class="c"># 明示的な形式</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span> <span class="c"># 暗黙で __exact を表す</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span> <span class="c"># pk は暗黙で id__exact を表す</span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">pk</span></tt> は <tt class="docutils literal"><span class="pre">__exact</span></tt> のクエリにしか使えないわけではありません。どのクエリ
用キーワードも <tt class="docutils literal"><span class="pre">pk</span></tt> と組み合わせてかまいません。 <tt class="docutils literal"><span class="pre">pk</span></tt> を使うと、モデル
の主キーに対するクエリを表します:</p>
<pre># id が 1, 4 および 7 のブログエントリを取得する
&gt;&gt;&gt; Blog.objects.filter(pk__in=[1,4,7])

# id &gt; 14 の全てのブログエントリを取得する
&gt;&gt;&gt; Blog.objects.filter(pk__gt=14)</pre>
<p><tt class="docutils literal"><span class="pre">pk</span></tt> による検索は join 越しでも行えます。 例えば、以下の二つの文は等価で
す:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__id__exact</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="c"># 明示的な形式</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__id</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>        <span class="c"># 暗黙で __exact を表す</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog__pk</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>        <span class="c"># __pk は暗黙で __id__exact を表す</span>
</pre></div>
</div>
<div class="section" id="s-like">
<span id="s-escaping-percent-signs-and-underscores-in-like-statements"></span><h3>LIKE 文におけるパーセント記号とアンダースコアのエスケープ<a class="headerlink" href="#like" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">LIKE</span></tt> を使う SQL 文になるようなフィールド照合メソッド (<tt class="docutils literal"><span class="pre">iexact</span></tt>,
<tt class="docutils literal"><span class="pre">contains</span></tt>, <tt class="docutils literal"><span class="pre">icontains</span></tt>, <tt class="docutils literal"><span class="pre">startswith</span></tt>, <tt class="docutils literal"><span class="pre">istartswith</span></tt>, <tt class="docutils literal"><span class="pre">endswith</span></tt>,
<tt class="docutils literal"><span class="pre">iendswith</span></tt>) では、 <tt class="docutils literal"><span class="pre">LIKE</span></tt> 文で使われる二つの特殊な文字、すなわちパーセ
ント記号とアンダースコアを自動的にエスケープします。 (<tt class="docutils literal"><span class="pre">LIKE</span></tt> 文では、パー
セント記号は任意の複数文字に対するワイルドカードを表し、アンダースコアは任
意の一文字に対するワイルドカードを表します。)</p>
<p>この機能によって、照合操作を直感的に行え、データベースの抽象化を守れます。
例えば、パーセント記号を含むようなエントリ全てを取得したければ、以下のよう
にパーセント記号をそのまま使います:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s">&#39;%&#39;</span><span class="p">)</span>
</pre></div>
<p>Django はクオートの処理に気を配ってくれます。 SQL は以下のような感じになり
ます:</p>
<div class="highlight"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">WHERE</span> <span class="n">headline</span> <span class="k">LIKE</span> <span class="s1">&#39;%\%%&#39;</span><span class="p">;</span>
</pre></div>
<p>アンダースコアについても同じようなエスケープを行います。パーセント記号とア
ンダースコアはいずれも透過的に処理されます。</p>
</div>
<div class="section" id="s-id21">
<span id="s-id20"></span><span id="s-caching-and-querysets"></span><h3>キャッシュとクエリセット<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h3>
<p>データベースへのアクセスを最小限にとどめるため、クエリセット各々にはキャッ
シュがあります。効率的なコードを書く上で、キャッシュのからくりを理解してお
くのは重要なことです。</p>
<p>クエリセットが新たに生成された時点では、キャッシュは空です。クエリセットを
最初に評価したとき (すなわち、データベースへのクエリが最初に生じたとき)、
Django はクエリ結果をクエリセットオブジェクト内のキャッシュに保存し、明示的
にリクエストした結果だけ (例えば、クエリセットに対してイテレーション操作を
する場合には、結果セットの最初の要素) を返します。それ以後は、クエリセット
を際利用するとキャッシュ済みの結果を返します。</p>
<p>このキャッシュの挙動をよく覚えておいて下さい。というのも、クエリセットを正
しく扱わないと、おもわぬところで手を噛まれるはめになるからです。例えば、以
下の例では二つのクエリセットを作成し、値を評価して、すぐにクエリセットを捨
ててしまっています:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">headline</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">pub_date</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()]</span>
</pre></div>
<p>そのため、全く同じデータベースクエリを二度実行し、データベースの負荷を倍加
させています。また、 <tt class="docutils literal"><span class="pre">Entry</span></tt> は二つのリクエストを処理する間にも追加された
り削除されたりする可能性があるため、二つのリストには必ずしも同じデータベー
スレコードが入っているとは限りません。</p>
<p>こうした問題を避けるには、クエリセットを保存して再利用してください:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">queryset</span> <span class="o">=</span> <span class="n">Poll</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">headline</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">queryset</span><span class="p">]</span> <span class="c"># クエリセットを評価します。</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">pub_date</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">queryset</span><span class="p">]</span> <span class="c"># キャッシュの値を再利用します。</span>
</pre></div>
</div>
</div>
<div class="section" id="s-q">
<span id="s-complex-lookups-with-q-objects"></span><h2>Q オブジェクトを使った複雑な照合<a class="headerlink" href="#q" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">filter()</span></tt> などで複数のキーワード引数を指定してクエリを行うと、各々のキー
ワード引数の表す照合条件は違いに &quot;AND&quot; で結ばれます。より複雑なクエリ (例え
ば <tt class="docutils literal"><span class="pre">OR</span></tt> を使ったクエリ) を実行する必要がある場合には <tt class="docutils literal"><span class="pre">Q</span></tt> オブジェクトを
使えます。</p>
<p><tt class="docutils literal"><span class="pre">Q</span></tt> オブジェクト (<tt class="docutils literal"><span class="pre">django.db.models.Q</span></tt>) は、複数のキーワード引数
をカプセル化するために使われます。キーワード引数は前述の 「フィールドの照合」
で説明したものと同じです。</p>
<p>例えば、以下の <tt class="docutils literal"><span class="pre">Q</span></tt> オブジェクトは単一の <tt class="docutils literal"><span class="pre">LIKE</span></tt> クエリをカプセル化してい
ます:</p>
<div class="highlight"><pre><span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s">&#39;What&#39;</span><span class="p">)</span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">Q</span></tt> オブジェクトは <tt class="docutils literal"><span class="pre">&amp;</span></tt> や <tt class="docutils literal"><span class="pre">|</span></tt> といった演算子で組み合わせられます。二
つの <tt class="docutils literal"><span class="pre">Q</span></tt> オブジェクトを演算子で結ぶと、新たな <tt class="docutils literal"><span class="pre">Q</span></tt> オブジェクトを生成し
ます。</p>
<p>例えば、以下の文は二つの <tt class="docutils literal"><span class="pre">question__startswith</span></tt> クエリを &quot;OR&quot; したものを
表す単一の <tt class="docutils literal"><span class="pre">Q</span></tt> オブジェクトを生成します:</p>
<div class="highlight"><pre><span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s">&#39;Who&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s">&#39;What&#39;</span><span class="p">)</span>
</pre></div>
<p>この <tt class="docutils literal"><span class="pre">Q</span></tt> オブジェクトは以下の <tt class="docutils literal"><span class="pre">WHERE</span></tt> 節と等価です:</p>
<pre>WHERE question LIKE 'Who%' OR question LIKE 'What%'</pre>
<p><tt class="docutils literal"><span class="pre">Q</span></tt> オブジェクトを <tt class="docutils literal"><span class="pre">&amp;</span></tt> と <tt class="docutils literal"><span class="pre">|</span></tt> で組み合わせれば、好きなだけ複雑なクエ
リ文を作成できます。丸括弧を使ったグルーピングも可能です。</p>
<p>キーワード引数をとる照合関数 (<tt class="docutils literal"><span class="pre">filter()</span></tt>, <tt class="docutils literal"><span class="pre">exclude()</span></tt>, <tt class="docutils literal"><span class="pre">get()</span></tt> など)
には、複数の <tt class="docutils literal"><span class="pre">Q</span></tt> を固定引数として (名前なしの引数として) 渡せます。複数の
<tt class="docutils literal"><span class="pre">Q</span></tt> オブジェクトを照合関数に渡した場合、それらは互いに &quot;AND&quot; で結ばれます。
例えば:</p>
<div class="highlight"><pre><span class="n">Poll</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">question__startswith</span><span class="o">=</span><span class="s">&#39;Who&#39;</span><span class="p">),</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="p">)</span>
</pre></div>
<p>は、だいたい以下のような SQL になります:</p>
<pre>SELECT * from polls WHERE question LIKE 'Who%'
    AND (pub_date = '2005-05-02' OR pub_date = '2005-05-06')</pre>
<p>照合関数は <tt class="docutils literal"><span class="pre">Q</span></tt> オブジェクトとキーワード引数を混ぜて使えます。照合関数に渡
した全ての引数は (キーワード引数も <tt class="docutils literal"><span class="pre">Q</span></tt> オブジェクトも) 互いに &quot;AND&quot; で結
ばれます。ただし、 <tt class="docutils literal"><span class="pre">Q</span></tt> を指定する場合はどのキーワード引数よりも前に指定せ
ねばなりません。たとえば:</p>
<div class="highlight"><pre><span class="n">Poll</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)),</span>
    <span class="n">question__startswith</span><span class="o">=</span><span class="s">&#39;Who&#39;</span><span class="p">)</span>
</pre></div>
<p>は有効なクエリで、前の例と同じになりますが、以下の文:</p>
<div class="highlight"><pre><span class="c"># INVALID QUERY</span>
<span class="n">Poll</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
    <span class="n">question__startswith</span><span class="o">=</span><span class="s">&#39;Who&#39;</span><span class="p">,</span>
    <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">|</span> <span class="n">Q</span><span class="p">(</span><span class="n">pub_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2005</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)))</span>
</pre></div>
<p>は無効です。</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference external" href="http://code.djangoproject.com/browser/django/trunk/tests/modeltests/or_lookups/models.py">OR lookups examples</a> の例には、 <tt class="docutils literal"><span class="pre">Q</span></tt> を使った Django のユニット
テストがあります。</p>
</div>
</div>
<div class="section" id="s-id22">
<span id="s-comparing-objects"></span><h2>オブジェクトの比較<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h2>
<p>二つのモデルオブジェクトを比較するには、標準の Python 比較演算子、すなわち
二重等号符: <tt class="docutils literal"><span class="pre">==</span></tt> を使います。背後では二つのモデルオブジェクト間の主キー値
が比較されます。</p>
<p>上の <tt class="docutils literal"><span class="pre">Entry</span></tt> の例では、以下の二つの文は等価です:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">some_entry</span> <span class="o">==</span> <span class="n">other_entry</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">some_entry</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">other_entry</span><span class="o">.</span><span class="n">id</span>
</pre></div>
<p>モデルの主キーが <tt class="docutils literal"><span class="pre">id</span></tt> という名前でなくても問題はありません。どのような名
前であれ、比較は常に主キーを使って行われます。例えば、モデルの主キーのフィー
ルド名が <tt class="docutils literal"><span class="pre">name</span></tt> であれば、以下の二つの文は等価です:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">some_obj</span> <span class="o">==</span> <span class="n">other_obj</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">some_obj</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
<div class="section" id="s-id23">
<span id="s-deleting-objects"></span><h2>オブジェクトの削除<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h2>
<p>削除用のメソッドには、便宜的に <tt class="docutils literal"><span class="pre">delete()</span></tt> という名前が付いてます。このメ
ソッドはオブジェクトをただちに削除し、戻り値を返しません:</p>
<div class="highlight"><pre><span class="n">e</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
<p>複数のオブジェクトの一斉削除も可能です。 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> には <tt class="docutils literal"><span class="pre">delete()</span></tt>
メソッドがあり、 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> の全てのメンバを削除します。</p>
<p>例えば、 <tt class="docutils literal"><span class="pre">pub_date</span></tt> が 2005 年の <tt class="docutils literal"><span class="pre">Entry</span></tt> オブジェクトを全て削除するには
以下のようにします:</p>
<div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2005</span><span class="p">)</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
<p>忘れてならないのは、この処理はできる限り SQL レベルで行われるため、
<tt class="docutils literal"><span class="pre">delete()</span></tt> メソッドが全てのインスタンスの <tt class="docutils literal"><span class="pre">delete()</span></tt> メソッドを呼ぶとは
限らないということです。モデルクラス上で <tt class="docutils literal"><span class="pre">delete()</span></tt> をカスタマイズしてい
て、オブジェクトを削除するときに呼び出したいのなら、 <tt class="docutils literal"><span class="pre">QuerySet</span></tt> の
<tt class="docutils literal"><span class="pre">delete()</span></tt> メソッドで一括削除するのではなく、直接(<tt class="docutils literal"><span class="pre">QuerySet</span></tt> の各要素を
取り出して逐次 <tt class="docutils literal"><span class="pre">delete()</span></tt> を呼ぶなどして) 「手動で」インスタンスを削除せ
ねばなりません。</p>
<p>Django は、オブジェクトを削除する際に、SQLでいう <tt class="docutils literal"><span class="pre">ON</span> <span class="pre">DELETE</span> <span class="pre">CASCADE</span></tt> 制約
をエミュレートします。すなわち、削除対象のオブジェクトを指すような外部キー
を持つ全てのオブジェクトも同時に削除されるのです。:</p>
<div class="highlight"><pre><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c"># 次の命令は、 Blog と Blog を指す Entry 全てを削除してしまいます。</span>
<span class="n">b</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">delete()</span></tt> は <tt class="docutils literal"><span class="pre">QuerySet</span></tt> のメソッドにすぎず、 <tt class="docutils literal"><span class="pre">Manager</span></tt> 自体には公開
されていないので注意してください。これは誤って <tt class="docutils literal"><span class="pre">Entry.objects.delete()</span></tt>
を実行して <em>全ての</em> エントリを削除してしまわないようにするための安全機構で
す。本当に全てのオブジェクトを削除 <em>したい</em> のなら、以下のように明示的に全
てのオブジェクトを表すクエリセットをリクエストしてください:</p>
<div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
<div class="section" id="s-id24">
<span id="s-updating-multiple-objects-at-once"></span><h2>複数のオブジェクトを一度に更新する<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h2>
<div class="versionadded">
<span class="title">Django 1.0 で新たに登場しました.</span> </div>
<p>クエリセットが表現する全てのオブジェクトのあるフィールドに特定の値を指定し
たいような場合があります。 <tt class="docutils literal"><span class="pre">update()</span></tt> メソッドを使えば、この処理を実現で
きます。例えば:</p>
<div class="highlight"><pre><span class="c"># pub_date が 2007 の全エントリのヘッドラインを更新する</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pub_date__year</span><span class="o">=</span><span class="mi">2007</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">headline</span><span class="o">=</span><span class="s">&#39;Everything is the same&#39;</span><span class="p">)</span>
</pre></div>
<p>この操作を行えるのは、リレーションフィールドでないフィールドか、
<tt class="docutils literal"><span class="pre">ForeignKey</span></tt> のフィールドのみです。また、フィールドに指定する値はハードコー
ドされた Python の値でなければなりません (つまり、その時の何らかのフィール
ド値は直接セットできません)。</p>
<p><tt class="docutils literal"><span class="pre">ForeignKey</span></tt> のフィールドを更新するには、以下のように、新たなモデルインス
タンスを作成して渡します:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="go"># 全てのエントリをこの blog に属させる</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">update()</span></tt> メソッドは (<tt class="docutils literal"><span class="pre">delete()</span></tt> と同様)、即座に適用され、値を返しませ
ん。また、更新対象のクエリセットには、モデルの主のテーブル一つに対してし
かアクセスできないという制限があります。従って、クエリセットを構築するとき
に、リレーション先のフィールドでフィルタしたりしてはなりません。複数のテー
ブルを操作するようなクエリセットに対しては、 <tt class="docutils literal"><span class="pre">update()</span></tt> は動作しません。</p>
<p><tt class="docutils literal"><span class="pre">update()</span></tt> メソッドは SQL 文に直接変換されるので注意してください。このメ
ソッドは、フィールド値の直接更新を大量一括実行するためのものです。
モデルの <tt class="docutils literal"><span class="pre">save()</span></tt> メソッドを呼出さないので、 (<tt class="docutils literal"><span class="pre">save()</span></tt> の呼び出しに連動
している) <tt class="docutils literal"><span class="pre">pre_save</span></tt> や <tt class="docutils literal"><span class="pre">post_save</span></tt> といったシグナルは発生しません。
クエリセット内の全ての要素に対して <tt class="docutils literal"><span class="pre">save()</span></tt> メソッドを適用したければ、
単に全要素に渡って <tt class="docutils literal"><span class="pre">save()</span></tt> を呼び出してください:</p>
<div class="highlight"><pre><span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">my_queryset</span><span class="p">:</span>
    <span class="n">item</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<div class="section" id="s-id25">
<span id="s-related-objects"></span><h2>リレーション<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h2>
<p>モデル内でリレーション (<tt class="docutils literal"><span class="pre">ForeignKey</span></tt>, <tt class="docutils literal"><span class="pre">OneToOneField</span></tt>,
<tt class="docutils literal"><span class="pre">ManyToManyField</span></tt>) を定義すると、そのモデルのインスタンスはリレーション先
のオブジェクトにアクセスするための便利な API を持つようになります。</p>
<p>このドキュメントの冒頭のモデルを例にとると、 <tt class="docutils literal"><span class="pre">Entry</span></tt> オブジェクト <tt class="docutils literal"><span class="pre">e</span></tt>
は、 <tt class="docutils literal"><span class="pre">e</span></tt> に関連づけられている <tt class="docutils literal"><span class="pre">Blog</span></tt> オブジェクトに <tt class="docutils literal"><span class="pre">blog</span></tt> という属性
を使って <tt class="docutils literal"><span class="pre">e.blog</span></tt> のようにアクセスできます。</p>
<p>(舞台裏では、この機能は Python の <a class="reference external" href="http://users.rcn.com/python/download/Descriptor.htm">デスクリプタ</a> を使って実装されています。
だからどうだというわけではありませんが、興味のある人のためにここで指摘して
おきます。)</p>
<p>Django はまた、リレーションの「相手側」へのアクセス API、すなわちリレーショ
ンを張られた側からリレーションを張った側のモデルへのリンクも作成します。例
えば、 <tt class="docutils literal"><span class="pre">Blog</span></tt> オブジェクト <tt class="docutils literal"><span class="pre">b</span></tt> は、リレーションを張った全ての <tt class="docutils literal"><span class="pre">Entry</span></tt>
オブジェクトのリストに <tt class="docutils literal"><span class="pre">entry_set</span></tt> 属性を使って <tt class="docutils literal"><span class="pre">b.entry_set.all()</span></tt> の
ようにアクセスできます。</p>
<p>この節での例は、全て冒頭に示した <tt class="docutils literal"><span class="pre">Blog</span></tt> <tt class="docutils literal"><span class="pre">Blog</span></tt>, <tt class="docutils literal"><span class="pre">Author</span></tt>, <tt class="docutils literal"><span class="pre">Entry</span></tt>
のモデルを使っています。</p>
<div class="section" id="s-id27">
<span id="s-one-to-many-relationships"></span><h3>一対多のリレーション<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h3>
<div class="section" id="s-id28">
<span id="s-forward"></span><h4>順方向<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h4>
<p>モデルに <tt class="docutils literal"><span class="pre">ForeignKey</span></tt> フィールドがある場合、そのモデルのインスタンスは、
単に属性を使ってリレーション先 (外部) のオブジェクトを参照できます。</p>
<p>例:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">blog</span> <span class="c"># リレーション先の Blog オブジェクトを返します。</span>
</pre></div>
<p>外部キー属性の値は取得 (get) も設定 (set) もできます。当然ながら、外部キー
への変更は <tt class="docutils literal"><span class="pre">save()</span></tt> を呼び出すまでデータベースに反映されません。例えば:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">blog</span> <span class="o">=</span> <span class="n">some_blog</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">ForeignKey</span></tt> フィールドに <tt class="docutils literal"><span class="pre">null=True</span></tt> が設定されていた場合 (<tt class="docutils literal"><span class="pre">NULL</span></tt> 値
を許している場合)、以下の例のように <tt class="xref docutils literal"><span class="pre">None</span></tt> を代入できます:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">blog</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">save</span><span class="p">()</span> <span class="c"># &quot;UPDATE blog_entry SET blog_id = NULL ...;&quot;</span>
</pre></div>
<p>一対多のリレーションで順方向のアクセスを行うと、その結果はリレーション先の
オブジェクトに最初にアクセスした際にキャッシュされます。それ以降のアクセス
では、同じオブジェクトインスタンスの外部キーへのアクセスはキャッシュされた
値を返します。例えば:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">e</span><span class="o">.</span><span class="n">blog</span>  <span class="c"># データベースを検索して、関連づけられた Blog を返します。</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">e</span><span class="o">.</span><span class="n">blog</span>  <span class="c"># データベースは検索せず、キャッシュを使います。</span>
</pre></div>
<p>クエリセットのメソッド <tt class="docutils literal"><span class="pre">select_related()</span></tt> を使うと、一対多のリレーション
のリレーション先オブジェクト全てをあらかじめ再帰的にキャッシュに取り込みま
す。例えば:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">e</span><span class="o">.</span><span class="n">blog</span>  <span class="c"># Doesn&#39;t hit the database; uses cached version.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">e</span><span class="o">.</span><span class="n">blog</span>  <span class="c"># Doesn&#39;t hit the database; uses cached version.</span>
</pre></div>
</div>
<div class="section" id="s-id29">
<span id="s-backwards-related-objects"></span><h4>「逆方向の」リレーション<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h4>
<p>あるモデルが <tt class="docutils literal"><span class="pre">ForeignKey</span></tt> で別のモデルにリレーションを張っている場合、リ
レーションを張られた側のモデルのインスタンスは、リレーションを張った側のモ
デルの全てのインスタンスを返すマネジャにアクセスでます。リレーションを張っ
ている側のモデル名を全て小文字にしたものを <tt class="docutils literal"><span class="pre">FOO</span></tt> とすると、マネジャの名前
のデフォルト値は <tt class="docutils literal"><span class="pre">FOO_set</span></tt> です。このマネジャはクエリセットを返します。ク
エリセットには前述の「オブジェクトの取得」の節で説明したフィルタや操作を行
えます。</p>
<p>例を示しましょう:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="c"># Blog に関連づけられた全ての Entry を返します。</span>

<span class="go"># b.entry_set はクエリセットを返すマネジャです。</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">ForeignKey</span></tt> を定義するときに <tt class="docutils literal"><span class="pre">related_name</span></tt> パラメタを設定しておくと、
<tt class="docutils literal"><span class="pre">FOO_set</span></tt> の名前をオーバライドできます。例えば、 <tt class="docutils literal"><span class="pre">Entry</span></tt> モデルの定義を
<tt class="docutils literal"><span class="pre">blog</span> <span class="pre">=</span> <span class="pre">ForeignKey(Blog,</span> <span class="pre">related_name='entries')</span></tt> のように改めると、上の
コード例は以下のようになります:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="c"># Blog に関連づけられた全ての Entry を返します。</span>

<span class="go"># b.entries はクエリセットを返すマネジャです。</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">headline__contains</span><span class="o">=</span><span class="s">&#39;Lennon&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">ForeignKey</span></tt> 逆参照は、マネジャとしてのアクセスはできず、インスタンスとし
てアクセスせねばなりません。例えば:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Blog</span><span class="o">.</span><span class="n">entry_set</span>
<span class="go">Traceback:</span>
<span class="go">    ...</span>
<span class="go">AttributeError: &quot;Manager must be accessed via instance&quot;.</span>
</pre></div>
<p>前述の「オブジェクトの取得」で説明したクエリセットのメソッドに加えて、
<tt class="docutils literal"><span class="pre">ForeignKey</span></tt> で表現されるマネジャには、リレーション元のオブジェクトの集合
を扱うための追加のメソッドがあります。メソッドの概要は以下に示しますが、詳
細は <a class="reference external" href="../../ref/models/relations.html#ref-models-relations"><em>リレーションのリファレンス</em></a> を参照してく
ださい。</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">add(obj1,</span> <span class="pre">obj2,</span> <span class="pre">...)</span></tt></dt>
<dd>引数に指定したモデルオブジェクトを、リレーション元オブジェクトの集合に
加えます。</dd>
<dt><tt class="docutils literal"><span class="pre">create(**kwargs)</span></tt></dt>
<dd>新たなオブジェクトを生成して保存し、リレーション元オブジェクトの集合に
加えます。生成されたオブジェクトを返します。</dd>
<dt><tt class="docutils literal"><span class="pre">remove(obj1,</span> <span class="pre">obj2,</span> <span class="pre">...)</span></tt></dt>
<dd>リレーション元のオブジェクトの集合から、引数に指定したモデルオブジェク
トを除去します。</dd>
<dt><tt class="docutils literal"><span class="pre">clear()</span></tt></dt>
<dd>リレーション元オブジェクトの集合から、全てのオブジェクトを除去します。</dd>
</dl>
<p>リレーション先セットのメンバを一括で代入するには、イテレーション可能オブジェ
クトを代入します。例えば:</p>
<div class="highlight"><pre><span class="n">b</span> <span class="o">=</span> <span class="n">Blog</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">entry_set</span> <span class="o">=</span> <span class="p">[</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">]</span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">clear()</span></tt> メソッドを利用できる場合に代入を行うと、まず <tt class="docutils literal"><span class="pre">entry_set</span></tt> から
全てのオブジェクトを除去しておき、その後で右辺の iterable (上の例ではリスト)
のオブジェクト追加します。 <tt class="docutils literal"><span class="pre">clear()</span></tt> メソッドを使えない場合は、
<tt class="docutils literal"><span class="pre">entry_set</span></tt> に既に存在するオブジェクトを削除せず、単に右辺の iterable 上
の全てのオブジェクトを追加します。</p>
<p>この節で説明した「逆方向の」操作は、いずれもデータベースを即時変更します。
操作結果は追加、新規作成、削除といった操作を行う度に即座に自動的にデータベー
スに保存されます。</p>
</div>
</div>
<div class="section" id="s-id30">
<h3>多対多のリレーション<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h3>
<p>多対多のリレーションの場合、リレーションの関係にあるモデルの一方は、互いに
もう一方にアクセスするための自動 API を獲得します。この API は一対多のリレー
ションにおける「逆方向の」参照のように動作します。</p>
<p>一対多のリレーションとの唯一の違いは、属性の名前づけ規則です。
<tt class="docutils literal"><span class="pre">ManyToManyField</span></tt> を定義した側のモデルはフィールド名をそのまま使いますが、
「反対側の」モデルでは、相手のモデルのモデル名を小文字にして、 <tt class="docutils literal"><span class="pre">'_set'</span></tt>
を追加したもの (一対多のリレーションにおける逆方向の参照と同じ) になります。</p>
<p>例を使って説明した方が理解しやすいでしょう:</p>
<div class="highlight"><pre><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">e</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="c"># Entry の全ての Author オブジェクトを返します。</span>
<span class="n">e</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class="n">e</span><span class="o">.</span><span class="n">authors</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">name__contains</span><span class="o">=</span><span class="s">&#39;John&#39;</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">Author</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">a</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="c"># Author の全ての Entry オブジェクトを返します。</span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">ForeignKey</span></tt> と同様、 <tt class="docutils literal"><span class="pre">ManyToManyField</span></tt> には <tt class="docutils literal"><span class="pre">related_name</span></tt> パラメタ
を指定できます。 上の例で、 <tt class="docutils literal"><span class="pre">Entry</span></tt> の <tt class="docutils literal"><span class="pre">ManyToManyField</span></tt> に
<tt class="docutils literal"><span class="pre">related_name='entries'</span></tt> を指定していた場合、 <tt class="docutils literal"><span class="pre">Author</span></tt> インスタンスは
<tt class="docutils literal"><span class="pre">entry_set</span></tt> ではなく <tt class="docutils literal"><span class="pre">entries</span></tt> という属性を持つようになります。</p>
</div>
<div class="section" id="s-id31">
<h3>一対一のリレーション<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h3>
<p>一対一 (one-to-one) のリレーションは多対多のリレーションと非常によく似てい
ます。モデルに <a title="django.db.models.OneToOneField" class="reference external" href="../../ref/models/fields.html#django.db.models.OneToOneField"><tt class="xref docutils literal"><span class="pre">OneToOneField</span></tt></a> を定義すると、モデ
ルのインスタンスはリレーション先のオブジェクトを簡単な属性アクセスで参照で
きます。</p>
<p>例を示します:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">EntryDetail</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">entry</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">OneToOneField</span><span class="p">(</span><span class="n">Entry</span><span class="p">)</span>
    <span class="n">details</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>

<span class="n">ed</span> <span class="o">=</span> <span class="n">EntryDetail</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ed</span><span class="o">.</span><span class="n">entry</span> <span class="c"># リレーション先の Entry オブジェクトを返します。</span>
</pre></div>
<p>多対多との違いは、逆参照のクエリです。多対多の時と同様、リレーション先のモ
デルはリレーション元のモデルに対するマネジャオブジェクトにアクセスできます
が、このマネジャはオブジェクトの集合ではなく単一のオブジェクトを表現してい
ます:</p>
<div class="highlight"><pre><span class="n">e</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">e</span><span class="o">.</span><span class="n">entrydetail</span> <span class="c"># リレーション先の EntryDetail オブジェクトを返します。</span>
</pre></div>
<p>逆リレーション先のオブジェクトが存在しなければ、 Django は <tt class="docutils literal"><span class="pre">DoesNotExist</span></tt>
例外を送出します。</p>
<p>逆参照のリレーションにインスタンスを代入すると、順参照のリレーションと同じ
ようにリレーション先を変更できます:</p>
<div class="highlight"><pre><span class="n">e</span><span class="o">.</span><span class="n">entrydetail</span> <span class="o">=</span> <span class="n">ed</span>
</pre></div>
</div>
<div class="section" id="s-id32">
<span id="s-how-are-the-backward-relationships-possible"></span><h3>リレーションの後方参照はどうやって実現されているのか<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h3>
<p>他のオブジェクトリレーショナルマッパでは、双方向からリレーションを定義せね
ばなりません。 Django の開発者たちはこれを DRY 則 (Don't Repeat Yourself)
の侵犯だと考えたため、 Django では片方だけでリレーションを定義すればよいよ
うにしています。</p>
<p>しかし、なぜあるモデルクラスが、自分に対してリレーションを張っているモデル
クラスのことを、そのクラスがロードされる前に検知できるのでしょうか？</p>
<p>答えは <a class="reference external" href="../../ref/settings.html#setting-INSTALLED_APPS"><tt class="xref docutils literal"><span class="pre">INSTALLED_APPS</span></tt></a> 設定にあります。最初にモデルをロードした時
に、 Django は <a class="reference external" href="../../ref/settings.html#setting-INSTALLED_APPS"><tt class="xref docutils literal"><span class="pre">INSTALLED_APPS</span></tt></a> の全てのモデルを走査して、必要に応
じて後方参照をメモリ中に作成します。 <a class="reference external" href="../../ref/settings.html#setting-INSTALLED_APPS"><tt class="xref docutils literal"><span class="pre">INSTALLED_APPS</span></tt></a> の本質的な機
能の一つは、 Django にモデルドメインの全体像を知らせることなのです。</p>
</div>
<div class="section" id="s-id33">
<span id="s-queries-over-related-objects"></span><h3>リレーション先オブジェクトを使ったクエリ<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h3>
<p>リレーション先のオブジェクトを照合条件に含むクエリは、通常の値のフィールド
の入ったクエリと同じような規則に従います。クエリにマッチ条件として値を指定
する場合、オブジェクトのインスタンス自体か、オブジェクトの主キー値のいずれ
かを使えます。</p>
<p>例えば、 <tt class="docutils literal"><span class="pre">id=5</span></tt> であるようなBlog オブジェクト <tt class="docutils literal"><span class="pre">b</span></tt> に対しては、以下の三
つのクエリはすべて等価です:</p>
<div class="highlight"><pre><span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="p">)</span> <span class="c"># オブジェクトインスタンスを使ったクエリ</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="n">b</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="c"># インスタンスの id を使ったクエリ</span>
<span class="n">Entry</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">blog</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="c"># id を直接使ったクエリ</span>
</pre></div>
</div>
</div>
<div class="section" id="s-sql">
<span id="s-falling-back-to-raw-sql"></span><h2>生 SQL へのフォールバック<a class="headerlink" href="#sql" title="Permalink to this headline">¶</a></h2>
<p>Django のデータベースマッパで扱うには複雑すぎる SQL 文を書かねばならないよ
うな場合には、生の SQL 文実行モードを使えます。</p>
<p>生 raw-SQL 文実行モードの使い方としてお勧めなのは、そのようなクエリ文を実行
するモデルのカスタムメソッドやカスタムマネジャのメソッドを実装するというも
のです。 Django はモデルレイヤでデータベースクエリを記述するように
<em>何ら要求してはいません</em> が、このアプローチをとることで、データアクセスのた
めのロジックを一箇所にまとめられるので、コード組織化の観点からスマートにな
ります。詳しい説明は <a class="reference external" href="sql.html#topics-db-sql"><em>SQL クエリの直接実行</em></a> を参照してください。</p>
<p>最後に、 Django のデータベースレイヤは単にデータベースへの一つのインタフェー
スに過ぎないということに注意しておきましょう。データベースには他のツールや
プログラム言語、データベースフレームワークを介してアクセスできます。データ
ベースについて Django 固有の何かがあるわけではないのです。</p>
</div>
</div>


          </div>         
        </div>
      </div>
      
        
          <div class="yui-b" id="sidebar">
            
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3>Table Of Contents</h3>
            <ul>
<li><a class="reference external" href="">クエリを生成する</a><ul>
<li><a class="reference external" href="#id2">オブジェクトの生成</a></li>
<li><a class="reference external" href="#id3">オブジェクトへの変更を保存する</a><ul>
<li><a class="reference external" href="#foreignkey-manytomanyfield"><tt class="docutils literal"><span class="pre">ForeignKey</span></tt> や <tt class="docutils literal"><span class="pre">ManyToManyField</span></tt> の保存</a></li>
</ul>
</li>
<li><a class="reference external" href="#id4">オブジェクトの取得</a><ul>
<li><a class="reference external" href="#id5">全てのオブジェクトの取得</a></li>
<li><a class="reference external" href="#id6">フィルタを使ってオブジェクトを取り出す</a><ul>
<li><a class="reference external" href="#id8">フィルタの連鎖</a></li>
<li><a class="reference external" href="#id10">フィルタしたクエリセットは一意なオブジェクトである</a></li>
<li><a class="reference external" href="#id12">クエリセットは遅延評価される</a></li>
<li><a class="reference external" href="#id13">その他のクエリセットメソッド</a></li>
</ul>
</li>
<li><a class="reference external" href="#id15">クエリセットに制約を課す</a></li>
<li><a class="reference external" href="#id16">フィールドの照合</a></li>
<li><a class="reference external" href="#id18">リレーションをまたいだ照合</a><ul>
<li><a class="reference external" href="#id19">多値のリレーションをスパンする</a></li>
</ul>
</li>
<li><a class="reference external" href="#pk">pk 照合ショートカット</a></li>
<li><a class="reference external" href="#like">LIKE 文におけるパーセント記号とアンダースコアのエスケープ</a></li>
<li><a class="reference external" href="#id21">キャッシュとクエリセット</a></li>
</ul>
</li>
<li><a class="reference external" href="#q">Q オブジェクトを使った複雑な照合</a></li>
<li><a class="reference external" href="#id22">オブジェクトの比較</a></li>
<li><a class="reference external" href="#id23">オブジェクトの削除</a></li>
<li><a class="reference external" href="#id24">複数のオブジェクトを一度に更新する</a></li>
<li><a class="reference external" href="#id25">リレーション</a><ul>
<li><a class="reference external" href="#id27">一対多のリレーション</a><ul>
<li><a class="reference external" href="#id28">順方向</a></li>
<li><a class="reference external" href="#id29">「逆方向の」リレーション</a></li>
</ul>
</li>
<li><a class="reference external" href="#id30">多対多のリレーション</a></li>
<li><a class="reference external" href="#id31">一対一のリレーション</a></li>
<li><a class="reference external" href="#id32">リレーションの後方参照はどうやって実現されているのか</a></li>
<li><a class="reference external" href="#id33">リレーション先オブジェクトを使ったクエリ</a></li>
</ul>
</li>
<li><a class="reference external" href="#sql">生 SQL へのフォールバック</a></li>
</ul>
</li>
</ul>

  <h3>前後のページ</h3>
  <ul>
    
      <li>前: <a href="models.html">モデルの作成</a></li>
    
    
      <li>次: <a href="managers.html">マネジャ</a></li>
    
  </ul>
  <h3>現在のページ:</h3>
  <ul>
      <li>
        <a href="../../index.html">Django v1.0 documentation</a>
        
          <ul><li><a href="../index.html">Django を使う</a>
        
          <ul><li><a href="index.html">モデルとデータベース</a>
        
        <ul><li>クエリを生成する</li></ul>
        </li></ul></li></ul>
      </li>
  </ul>  

            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../../_sources/topics/db/queries.txt">Show Source</a></li>
            </ul>
            <h3>Quick search</h3>
            <form class="search" action="../../search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
      </div>
              <h3>Last update:</h3>
              <p class="topless">Aug 31, 2012</p>
          </div> 
        
      
    </div>
    
    <div id="ft">
      <div class="nav">
    &laquo; <a href="models.html" title="モデルの作成">前へ</a> 
     |
    <a href="../index.html" title="Django を使う" accesskey="U">上へ</a>
   |
    <a href="managers.html" title="マネジャ">次へ</a> &raquo;</div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>