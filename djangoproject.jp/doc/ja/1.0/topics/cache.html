<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Django のキャッシュフレームワーク &mdash; Django v1.0 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '1.0',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="contents" title="Global table of contents" href="../contents.html" />
    <link rel="index" title="Global index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="top" title="Django v1.0 documentation" href="../index.html" />
    <link rel="up" title="Django を使う" href="index.html" />
    <link rel="next" title="電子メールの送信" href="email.html" />
    <link rel="prev" title="Django でのユーザ認証" href="auth.html" />
  </head>
  <body>
  <div id="outdated-warning" class="doc-floating-warning" style="position: relative;">
    このドキュメントの Django のバージョンにはセキュリティ上の脆弱性があるため、すでにサポートが終了されています。新しいバージョンにアップグレードしてください！<a href="https://docs.djangoproject.com/ja/">最新の Django のバージョンのドキュメントはこちら</a>
  </div>
  <div id="custom-doc" class="yui-t6">
    <div id="hd">
      <h1><a href="../index.html">Django v1.0 documentation</a></h1>
      <div id="global-nav">
        <a title="Home page" href="../index.html">ホーム</a>  |
        <a title="Table of contents" href="../contents.html">目次</a>  |
        <a title="Global index" href="../genindex.html">索引</a>  |
        <a title="Search" href="../modindex.html">モジュール一覧</a>
      </div>
      <div class="nav">
    &laquo; <a href="auth.html" title="Django でのユーザ認証">前へ</a> 
     |
    <a href="index.html" title="Django を使う" accesskey="U">上へ</a>
   |
    <a href="email.html" title="電子メールの送信">次へ</a> &raquo;</div>
    </div>
    
    <div id="bd">
      <div id="yui-main">
        <div class="yui-b">
          <div class="yui-g" id="topics-cache">
            
  
  <div class="section" id="s-django">
<span id="s-topics-cache"></span><h1>Django のキャッシュフレームワーク<a class="headerlink" href="#django" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">revision-up-to:</th><td class="field-body">8961 (1.0)</td>
</tr>
</tbody>
</table>
<p>動的な Web サイトの根本的なトレードオフ要因とは、まさに動的であるということ
そのものです。ユーザがページをリクエストするたびに、サーバはデータベースへ
のクエリからテンプレートのレンダリングやビジネスロジックといった全ての計算
を実行して、サイト訪問者が見るページを生成します。これは、処理のオーバヘッ
ドという観点から考えると、ファイルシステムからファイルを読み出すタイプの標
準的なサーバ設計よりもはるかに高くつきます。</p>
<p>ほとんどの Web アプリケーションでは、このオーバヘッドはたいしたものではあり
ません。ほとんどの Web アプリケーションは washingtonpost.com や
slashdot.org とは違って、小規模から中規模のサイトであり、トラフィックもそこ
そこにすぎません。しかし、中規模以上のサイトや高いトラフィックをさばかねば
ならないサイトでは、可能なかぎりオーバヘッドを削るのは基本です。</p>
<p>そこでキャッシュが登場します。</p>
<p>コンテンツのキャッシュとは、コストのかかる計算で、かつ一度計算したら再度計
算する必要のないものの結果を保存することです。以下の疑似コードは、動的に生
成されるWeb ページで、キャッシュがどのように動作するかを説明しています:</p>
<pre># ある URL に対し、キャッシュに該当するページがないか探す
given a URL, try finding that page in the cache
# キャッシュ内にページがある場合
if the page is in the cache:
    # キャッシュされたページを返す
    return the cached page
else:
    # ページを生成する
    generate the page
    # 生成されたページを (次のリクエスト用に) キャッシュに保存
    save the generated page in the cache (for next time)
    # 生成されたページを返す。
    return the generated page</pre>
<p>Django には堅牢なキャッシュシステムが付属しており、動的なページを保存して、
リクエストの度に最計算しなくてもよいようになっています。利便性のため、
Django には様々な粒度でのキャッシュを提供しており。特定のビューだけをキャッ
シュしたり、生成に時間を要する部分だけをキャッシュしたり、サイト全体をキャッ
シュしたりできます。</p>
<p>Django は Squid (<a class="reference external" href="http://www.squid-cache.org/">http://www.squid-cache.org/</a>) のような「上流の」キャッシュ
や、ブラウザベースのキャッシュともうまく協調できます。こうした類のキャッシュ
は直接制御できませんが、サイトのどの部分をどのようにキャッシュすべきかを
(HTTP ヘッダを介して) ヒントとして与えられます。</p>
<div class="section" id="s-id1">
<span id="s-setting-up-the-cache"></span><h2>キャッシュを立ち上げる<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>キャッシュシステムを使うには、少し設定が必要です。例えば、キャッシュデータ
をどこに置くか、データベース上か、ファイルシステム上か、それともメモリ上か
を指定せねばなりません。これはキャッシュのパフォーマンスに影響する重要な決
定です; そう、あるキャッシュ方式が別の方式より高速な場合もあるのです。</p>
<p>キャッシュの選択は設定ファイルの <a class="reference external" href="../ref/settings.html#setting-CACHE_BACKEND"><tt class="xref docutils literal"><span class="pre">CACHE_BACKEND</span></tt></a> 設定で行います。
CACHE_BACKEND に設定できる値を以下に示します。</p>
<div class="section" id="s-memcached">
<h3>memcached<a class="headerlink" href="#memcached" title="Permalink to this headline">¶</a></h3>
<p>Django で利用できるキャッシュの中でも断然高速で、もっとも高効率である
memcached は、完全なメモリベースのキャッシュフレームワークです。 memcached
はもともと LiveJournal.com の高負荷を低減するために開発され、その後 Danga
Interactive でオープンソース化されました。 memcached は Slashdot や
Wikipedia で使われており、データベースアクセスを低減して、サイトのパフォー
マンスを劇的に向上させます。</p>
<p>memcached は <a class="reference external" href="http://danga.com/memcached/">http://danga.com/memcached/</a> から無料で入手できます。 memcached
はデーモンとして動作し、指定された量の RAM の割り当てを受けます。 memcached
の役割は、キャッシュ内に任意のデータを追加し、取り出したり削除したりするた
めのインタフェース、それも <em>超稲妻迅い</em> インタフェースを提供することにあり
ます。全てのデータは直接メモリ上に保存されるので、データベースやファイルシ
ステムの使用によるオーバヘッドがなくなります。</p>
<p>memcached 本体のインストールの他に、 memcached の Python バインディングをイ
ンストールする必要があります。 memcached には二つのバージョンがあります。以
下の <em>どちらかの</em> モジュールを選んでインストールしてください。</p>
<ul class="simple">
<li>最も高速に memcached をドライブできる選択肢は、
<a class="reference external" href="http://gijsbert.org/cmemcache/">http://gijsbert.org/cmemcache/</a> から入手できる <tt class="docutils literal"><span class="pre">cmemcache</span></tt> です。 (こ
のモジュールは、開発版の Django でしか使えません。 Django 0.96 とそれ以
前のバージョンは下の選択肢を使ってください)。</li>
<li><tt class="docutils literal"><span class="pre">cmemcache</span></tt> を使えないなら、 <tt class="docutils literal"><span class="pre">python-memcached</span></tt> を使ってください。
<a class="reference external" href="ftp://ftp.tummy.com/pub/python-memcached/">ftp://ftp.tummy.com/pub/python-memcached/</a> で入手できます。この URL が有
効でなくなっていたら、 memcached のウェブサイト
(<a class="reference external" href="http://www.danga.com/memcached/">http://www.danga.com/memcached/</a>) に行って、 &quot;Client API&quot; セクションか
らPython バインディングを入手してください。</li>
</ul>
<p>Django を memcached と組み合わせて使うには、 <a class="reference external" href="../ref/settings.html#setting-CACHE_BACKEND"><tt class="xref docutils literal"><span class="pre">CACHE_BACKEND</span></tt></a> を
<tt class="docutils literal"><span class="pre">memcached://ip:port/</span></tt> に設定します。 <tt class="docutils literal"><span class="pre">ip</span></tt> は memcached デーモンを動か
しているホストの IP アドレス、 <tt class="docutils literal"><span class="pre">port</span></tt> はポート番号です。</p>
<p>以下の例では、 memcached をローカルホスト (127.0.0.1) のポート番号 11211
で動かしています:</p>
<div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&#39;memcached://127.0.0.1:11211/&#39;</span>
</pre></div>
<p>memcached の素晴らしい点の一つは、複数のサーバ間でキャッシュを共有できると
いうことです。この機能を利用するには、全てのサーバアドレスをセミコロンで区
切って <a class="reference external" href="../ref/settings.html#setting-CACHE_BACKEND"><tt class="xref docutils literal"><span class="pre">CACHE_BACKEND</span></tt></a> に設定します。以下の例では、 IP アドレスが
172.19.26.240 と 172.19.26.242 で、いずれもポート番号 11211 で動作している
memcached インスタンスでキャッシュを共有しています:</p>
<div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&#39;memcached://172.19.26.240:11211;172.19.26.242:11211/&#39;</span>
</pre></div>
<p>メモリベースのキャッシュには一つだけ短所があります: キャッシュデータはメモ
リ上に保存されるので、サーバクラッシュ時に失われることがあります。いうまで
もなく、メモリは永続的なデータ保存場所ではありません。ですから、データの保
存場所を確保するのにメモリベースのキャッシュに依存してはなりません。実際に
は、 Django のキャッシュバックエンドのいずれも永続的な記憶装置にはなりえま
せん -- キャッシュバックエンドは記憶装置ではなく、あくまでもキャッシュ用で
す -- ただ、メモリベースのキャッシュは特に一時性が高いため、ここで注意して
おきます。</p>
</div>
<div class="section" id="s-id2">
<span id="s-database-caching"></span><h3>データベースを使ったキャッシュ<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>データベーステーブルをキャッシュバックエンドに使うには、まず以下のコマンド
を実行してデータベース上にキャッシュテーブルを作成します:</p>
<pre>python manage.py createcachetable [cache_table_name]</pre>
<p><tt class="docutils literal"><span class="pre">[cache_table_name]</span></tt> は作成したいデータベーステーブルの名前です。 (この名
前は、現在データベースで既に使われていない有効なテーブル名なら何でも構いま
せん。) このコマンドはデータベース中に Django のデータベースキャッシュシス
テム向けの適切な形式のテーブルを生成します。</p>
<p>キャッシュ用のテーブルを作成したら、 <a class="reference external" href="../ref/settings.html#setting-CACHE_BACKEND"><tt class="xref docutils literal"><span class="pre">CACHE_BACKEND</span></tt></a> 設定を
<tt class="docutils literal"><span class="pre">&quot;db://tablename&quot;</span></tt> にします。 <tt class="docutils literal"><span class="pre">tablename</span></tt> はキャッシュ用テーブルの名前
です。以下の例では、キャッシュテーブル名を <tt class="docutils literal"><span class="pre">my_cache_table</span></tt> にしています:</p>
<div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&#39;db://my_cache_table&#39;</span>
</pre></div>
<p>データベースのキャッシュがうまく働くのは、高速でインデクス構築のよくできた
データベースサーバを使っている場合です。</p>
</div>
<div class="section" id="s-id3">
<span id="s-filesystem-caching"></span><h3>ファイルシステムを使ったキャッシュ<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>ファイルシステム上にキャッシュしたい内容を置くには、
<a class="reference external" href="../ref/settings.html#setting-CACHE_BACKEND"><tt class="xref docutils literal"><span class="pre">CACHE_BACKEND</span></tt></a> に <tt class="docutils literal"><span class="pre">&quot;file://&quot;</span></tt> キャッシュ形式を指定します。例え
ば、キャッシュデータを <tt class="docutils literal"><span class="pre">/var/tmp/django_cache</span></tt> に置きたいなら、以下の
ように設定します:</p>
<div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&#39;file:///var/tmp/django_cache&#39;</span>
</pre></div>
<p>先頭にスラッシュが 3 つ連なっていることに注意して下さい。最初の 2 つのスラッ
シュや <tt class="docutils literal"><span class="pre">file://</span></tt> の一部で、最後のスラッシュはディレクトリパス
<tt class="docutils literal"><span class="pre">/var/tmp/django_cache</span></tt> の最初の文字です。</p>
<p>ディレクトリパスは常に絶対パス指定。すなわち、ファイルシステムのルートから
始まるパス名を指定せねばなりません。パスの末尾にスラッシュを追加するかどう
かは問題にはなりません。</p>
<p>この設定の指し示すパスが実在し、 Web サーバを動かしているシステムユーザから
読み書き可能であるようにしてください。上の例でいうなら、サーバを <tt class="docutils literal"><span class="pre">apache</span></tt>
というユーザで動かしている場合、 <tt class="docutils literal"><span class="pre">/var/tmp/django_cache</span></tt> ディレクトリ
が実在して、 <tt class="docutils literal"><span class="pre">apache</span></tt> によって読み書き可能かどうかをチェックしてください。</p>
</div>
<div class="section" id="s-id4">
<span id="s-local-memory-caching"></span><h3>ローカルメモリ上のキャッシュ<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>メモリを使ったキャッシュの恩恵を受けたい一方で、 memcached を動かせない状況
にある場合には、ローカルメモリを使ったキャッシュバックエンドを検討してみて
ください。このキャッシュはマルチプロセスセーフかつスレッドセーフです。使う
には、 <a class="reference external" href="../ref/settings.html#setting-CACHE_BACKEND"><tt class="xref docutils literal"><span class="pre">CACHE_BACKEND</span></tt></a> に <tt class="docutils literal"><span class="pre">&quot;locmem:///&quot;</span></tt> と指定します。
以下のようにして使います:</p>
<div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&#39;locmem:///&#39;</span>
</pre></div>
<p>各サーバプロセスは、個別にキャッシュインスタンスを保持するので、プロセス間
でキャッシュは共有されません。このことから、明らかに、ローカルメモリキャッ
シュのメモリ効率は非常に悪いといえます。おそらく実運用環境向きとではないで
しょう。</p>
</div>
<div class="section" id="s-id5">
<span id="s-dummy-caching-for-development"></span><h3>ダミーキャッシュ (開発用)<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>最後に、 Django には「ダミーの」キャッシュが付いてきます。このキャッシュは
実際にはなにもしません -- 単に何もしないキャッシュインタフェースを実装して
いるだけです。</p>
<p>ダミーキャッシュが便利になるのは、そこかしこで様々なキャッシュを使っている
ような実運用サイトを構築していて、開発／テスト環境ではキャッシュを行いたく
ないような場合です。開発環境ではダミーキャッシュによってキャッシュしなくな
りますが、実運用環境はそのままにしておけます。ダミーキャッシュを有効にする
には、次のように <a class="reference external" href="../ref/settings.html#setting-CACHE_BACKEND"><tt class="xref docutils literal"><span class="pre">CACHE_BACKEND</span></tt></a> を設定します:</p>
<div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&#39;dummy:///&#39;</span>
</pre></div>
</div>
<div class="section" id="s-id6">
<h3>カスタムのキャッシュバックエンドを使う<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<div class="versionadded">
<span class="title">Django 1.0 で新たに登場しました.</span> </div>
<p>Django には、すぐに使えるキャッシュバックエンドがいくつもありますが、カスタ
マイズしたバックエンドや自作のバックエンドを使いたい場合もあるでしょう。
外部のキャッシュバックエンドを Django と組み合わせたいなら、以下のように、
Python の import パスを <a class="reference external" href="../ref/settings.html#setting-CACHE_BACKEND"><tt class="xref docutils literal"><span class="pre">CACHE_BACKEND</span></tt></a> の URI のスキーム部分 (最
初のコロンより前の部分) に指定します:</p>
<div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&#39;path.to.backend://&#39;</span>
</pre></div>
<p>自作のバックエンドを作成しているなら、リファレンス実装として標準のキャッシュ
バックエンドを使うとよいでしょう。キャッシュバックエンドは Django のソース
中の <tt class="docutils literal"><span class="pre">django/core/cache/backends/</span></tt> ディレクトリ下にあります。</p>
<p>注意: 運用ホスト上でサポートされていないなど、本当に特別な理由がないかぎり、
Django 組み込みのキャッシュバックエンドを使った方がよいでしょう。組み込みの
バックエンドは良くテストされており、とても簡単に扱えます。</p>
</div>
<div class="section" id="s-cache-backend">
<span id="s-cache-backend-arguments"></span><h3>CACHE_BACKEND の引数<a class="headerlink" href="#cache-backend" title="Permalink to this headline">¶</a></h3>
<p>これらのキャッシュは全て引数をとれます。引数はクエリ文字列の形式をとります。
使える引数は以下の通りです:</p>
<dl class="docutils">
<dt>timeout</dt>
<dd>デフォルトのタイムアウトで、単位は秒です。デフォルト値は 5 分 (300
秒) に設定されています。</dd>
<dt>max_entries</dt>
<dd>simple および database バックエンド用の引数で、キャッシュの消去を
行わずに残しておけるエントリの最大数です。デフォルト値は 300 です。</dd>
<dt>cull_percentage</dt>
<dd><p class="first">キャッシュ内のエントリ数が max_entries を越えたときに淘汰されるエン
トリの割合です。実際の百分率は 1/cull_percentage で決定されます。従っ
て、キャッシュエントリ数が max_entries を越えたときに全体の 1/3 の
エントリを淘汰したければ、 <tt class="docutils literal"><span class="pre">cull_percentage=3</span></tt> と設定します。</p>
<p class="last">cull_percentage に 0 を指定すると、キャッシュエントリ数が
max_entries に到達した時に全てのキャッシュエントリを廃棄します。
この設定は、キャッシュミスの増加と引き換えに、淘汰処理を <em>劇的に</em>
高速化します。</p>
</dd>
</dl>
<p>以下の例では、タイムアウトは <tt class="docutils literal"><span class="pre">60</span></tt> に設定されています:</p>
<div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&quot;memcached://127.0.0.1:11211/?timeout=60&quot;</span>
</pre></div>
<p>不正な引数や引数値は暗黙のうちに無視されます。</p>
<p>In this example, <tt class="docutils literal"><span class="pre">timeout</span></tt> is <tt class="docutils literal"><span class="pre">30</span></tt> and <tt class="docutils literal"><span class="pre">max_entries</span></tt> is <tt class="docutils literal"><span class="pre">400</span></tt>:</p>
<div class="highlight"><pre><span class="n">CACHE_BACKEND</span> <span class="o">=</span> <span class="s">&quot;memcached://127.0.0.1:11211/?timeout=30&amp;max_entries=400&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="s-id7">
<span id="s-the-per-site-cache"></span><h2>サイト単位のキャッシュ<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<div class="versionchanged">
<span class="title">Django 1.0 で変更されました:</span> (previous versions of Django only provided a single <tt class="docutils literal"><span class="pre">CacheMiddleware</span></tt> instead
of the two pieces described below).</div>
<p>キャッシュの立ち上げ後、最も簡単なキャッシュの用法はサイト全体のキャッシュ
です。設定は設定ファイルの <a class="reference external" href="../ref/settings.html#setting-MIDDLEWARE_CLASSES"><tt class="xref docutils literal"><span class="pre">MIDDLEWARE_CLASSES</span></tt></a> に
<tt class="docutils literal"><span class="pre">'django.middleware.cache.UpdateCacheMiddleware'</span></tt> と
<tt class="docutils literal"><span class="pre">'django.middleware.cache.FetchFromCacheMiddleware'</span></tt> を追加するだけです。
例えば以下のようにします:</p>
<div class="highlight"><pre><span class="n">MIDDLEWARE_CLASSES</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s">&#39;django.middleware.cache.UpdateCacheMiddleware&#39;</span><span class="p">,</span>
    <span class="s">&#39;django.middleware.common.CommonMiddleware&#39;</span><span class="p">,</span>
    <span class="s">&#39;django.middleware.cache.FetchFromCacheMiddleware&#39;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">そう、ミドルウェアの順番は、これで間違っていません。 &quot;Update&quot; ミドルウェ
アがリストの先頭で、 &quot;Fetch&quot; ミドルウェアが末尾です。詳しいからくりは
ちょっとややこしいのですが、後述の <a class="reference internal" href="#middleware-classes">MIDDLEWARE_CLASSES の順番</a> で説明
しています。</p>
</div>
<p>次に、以下の必須の設定を Django 設定ファイルに追加します:</p>
<ul class="simple">
<li><a class="reference external" href="../ref/settings.html#setting-CACHE_MIDDLEWARE_SECONDS"><tt class="xref docutils literal"><span class="pre">CACHE_MIDDLEWARE_SECONDS</span></tt></a> -- 各ページのキャッシュ時間を秒単位で
指定します。</li>
<li><a class="reference external" href="../ref/settings.html#setting-CACHE_MIDDLEWARE_KEY_PREFIX"><tt class="xref docutils literal"><span class="pre">CACHE_MIDDLEWARE_KEY_PREFIX</span></tt></a> -- 同じ Django の下にある複数のサ
イト間でキャッシュを共有する場合、この値をサイトの名前にするか、 Django
インスタンスごとに固有の文字列にして、キャッシュのキー衝突を防ぎます。キー
衝突を気にする必要がない場合は空文字列を設定します。</li>
</ul>
<p>キャッシュミドルウェアは GET または POST パラメタをもたない全てのページを
キャッシュします。オプションとして、
<tt class="xref docutils literal"><span class="pre">CACHE_MIDDLEWARE_ANONYMOUS_ONLY</span></tt> 設定を <tt class="xref docutils literal"><span class="pre">True</span></tt> にすると、匿名の
リクエスト (すなわちログインユーザ以外からのリクエスト) だけをキャッシュし
ます。これは (Django の adminインタフェースを含む) ユーザ固有のページに対す
るキャッシュを無効化する際に便利です。ただし、
<tt class="xref docutils literal"><span class="pre">CACHE_MIDDLEWARE_ANONYMOUS_ONLY</span></tt> を使う場合は、必ず
<tt class="xref docutils literal"><span class="pre">AuthenticationMiddleware</span></tt> を有効に
してください。</p>
<p>加えて、キャッシュミドルウェアは自動的に以下のヘッダを <tt class="docutils literal"><span class="pre">HttpResponse</span></tt> に追
加します:</p>
<ul class="simple">
<li>「新鮮な」(キャッシュされていない) ページをリクエストされた場合には、
<tt class="docutils literal"><span class="pre">Last-Modified</span></tt> ヘッダを現在の date/time に設定します。</li>
<li><tt class="docutils literal"><span class="pre">Expires</span></tt> ヘッダを現在時刻と <tt class="docutils literal"><span class="pre">CACHE_MIDDLEWARE_SECONDS</span></tt> を加算した
値に設定します。</li>
<li><tt class="docutils literal"><span class="pre">CACHE_MIDDLEWARE_SECONDS</span></tt> に基づき、 <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> ヘッダにページ
の最長寿命を設定します。</li>
</ul>
<p>ミドルウェアの詳細は <a class="reference external" href="http/middleware.html#topics-http-middleware"><em>ミドルウェア</em></a> を参照してください。</p>
<div class="versionadded">
<span class="title">Django 1.0 で新たに登場しました.</span> </div>
<p>ビューの中でキャッシュの有効期限を設定した場合 (<tt class="docutils literal"><span class="pre">Cache-Control</span></tt> ヘッダの
<tt class="docutils literal"><span class="pre">max-age</span></tt> セクションを設定した場合)、ページは
<tt class="docutils literal"><span class="pre">CACHE_MIDDLEWARE_SECONDS</span></tt> の設定値ではなくビューで設定した有効期限の下で
キャッシュされます。 <tt class="docutils literal"><span class="pre">django.views.decorators.cache</span></tt> モジュールのデコレー
タを使えば、ビューの有効期限を設定  (<tt class="docutils literal"><span class="pre">cache_control</span></tt> デコレータ) したり、
ビューのキャッシュを抑制 (<tt class="docutils literal"><span class="pre">never_cache</span></tt> デコレータ) できます。これらのデ
コレータについては <a class="reference internal" href="#id12">Vary ヘッダ以外のヘッダを使ったキャッシュ制御</a> を参照
してください。</p>
</div>
<div class="section" id="s-id8">
<span id="s-the-per-view-cache"></span><h2>ビュー単位のキャッシュ<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>キャッシュフレームワークをもう少し低い粒度で使うには、個々のビューの出力を
キャッシュします。 <tt class="docutils literal"><span class="pre">django.views.decorators.cache</span></tt> には関数デコレータ
<tt class="docutils literal"><span class="pre">cache_page</span></tt> があり、自動的にビューからの応答をキャッシュします。
使い方は簡単です:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.views.decorators.cache</span> <span class="kn">import</span> <span class="n">cache_page</span>

<span class="k">def</span> <span class="nf">slashdot_this</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>

<span class="n">slashdot_this</span> <span class="o">=</span> <span class="n">cache_page</span><span class="p">(</span><span class="n">slashdot_this</span><span class="p">,</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">15</span><span class="p">)</span>
</pre></div>
<p>Python 2.4 のデコレータ構文を使うと以下のようになります:</p>
<div class="highlight"><pre><span class="nd">@cache_page</span><span class="p">(</span><span class="mi">60</span> <span class="o">*</span> <span class="mi">15</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">slashdot_this</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">cache_page</span></tt> は単一の引数をとります。これはキャッシュのタイムアウトを秒で
表したものです。上の例では、  <tt class="docutils literal"><span class="pre">slashdot_this()</span></tt> の出力結果は 15 分間キャッ
シュされます。</p>
</div>
<div class="section" id="s-id9">
<span id="s-template-fragment-caching"></span><h2>テンプレートの部分的キャッシュ<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p><strong>開発版の Django で新たに追加された機能です</strong></p>
<p>ページのキャッシュをもっと細かく制御したいなら、 <tt class="docutils literal"><span class="pre">cache</span></tt> テンプレートタグ
を使って、テンプレートの一部分だけをキャッシュできます。 <tt class="docutils literal"><span class="pre">cache</span></tt> タグをテ
ンプレート内で使えるようにするには、テンプレートの冒頭に
<tt class="docutils literal"><span class="pre">{%</span> <span class="pre">load</span> <span class="pre">cache</span> <span class="pre">%}</span></tt> を挿入しておきます。</p>
<p><tt class="docutils literal"><span class="pre">{%</span> <span class="pre">cache</span> <span class="pre">%}</span></tt> テンプレートタグは、タグで囲まれたブロックの内容を、指定さ
れた時間だけキャッシュします。 <tt class="docutils literal"><span class="pre">cahce</span></tt> タグは、必須の引数として、キャッシュ
の有効期限 (秒単位) とキャッシュされた部分に付ける名前をとります。例えば、
以下のように使います:</p>
<pre>{% load cache %}
{% cache 500 sidebar %}
    .. sidebar ..
{% endcache %}</pre>
<p>キャッシュ部分内で使われる変数に応じて、複数のキャッシュコピーを保存したい
場合もあるでしょう。例えば、上の例で挙げたサイドバー部分を、ユーザ毎に個別
にキャッシュしたい場合には、 <tt class="docutils literal"><span class="pre">{%</span> <span class="pre">cache</span> <span class="pre">%}</span></tt> テンプレートタグに追加の引数を
指定して、キャッシュをユーザ毎に一意に識別できるようにします:</p>
<pre>{% load cache %}
{% cache 500 sidebar request.user.username %}
    .. sidebar for logged in user ..
{% endcache %}</pre>
<p>キャッシュ変数は、複数指定しても全く問題ありません。必要なだけの引数を
<tt class="docutils literal"><span class="pre">{%</span> <span class="pre">cache</span> <span class="pre">%}</span></tt> に指定してください。</p>
<p>キャッシュのタイムアウトはテンプレート変数でも指定できます。ただし、テンプ
レート変数は整数値でなければなりません。例えば、テンプレート変数
<tt class="docutils literal"><span class="pre">my_timeout</span></tt> を <tt class="docutils literal"><span class="pre">600</span></tt> にセットしていれば、以下の二つの例は同じ効果をも
たらします:</p>
<pre>{% cache 600 sidebar %} ... {% endcache %}
{% cache my_timeout sidebar %} ... {% endcache %}</pre>
<p>この機能を使えば、テンプレートで何度もタイムアウトを編集しなくても、一箇所
で変数を宣言しておいて再利用できるので便利です。</p>
</div>
<div class="section" id="s-api">
<span id="s-the-low-level-cache-api"></span><h2>低水準のキャッシュ API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<p>ときに、レンダリングされたページ全体のキャッシュが十分でないことがあります。
例えば、集約的なデータベースのクエリだけをキャッシュすればよいと考えるかも
しれません。このような場合のために、低水準のキャッシュ API を使って、オブジェ
クトを好きな粒度でキャッシュに保存できます。</p>
<p>キャッシュ API は簡単なものです。キャッシュを表現するモジュールである
<tt class="docutils literal"><span class="pre">django.core.cache</span></tt> は <tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt> 設定に基づいて生成された
<tt class="docutils literal"><span class="pre">cache</span></tt> オブジェクトを公開しています:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">django.core.cache</span> <span class="kn">import</span> <span class="n">cache</span>
</pre></div>
<p>基本となるインタフェースは <tt class="docutils literal"><span class="pre">set(key,</span> <span class="pre">value,</span> <span class="pre">timeout_seconds)</span></tt> と
<tt class="docutils literal"><span class="pre">get(key)</span></tt> です:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;my_key&#39;</span><span class="p">,</span> <span class="s">&#39;hello, world!&#39;</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;my_key&#39;</span><span class="p">)</span>
<span class="go">&#39;hello, world!&#39;</span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">timeout_seconds</span></tt> 引数はオプションで、デフォルト値は <tt class="docutils literal"><span class="pre">CACHE_BACKEND</span></tt> 設
定の timeout 引数の値になります (これについては上記を参照してください)。</p>
<p>オブジェクトがキャッシュの中になければ、 <tt class="docutils literal"><span class="pre">cache.get()</span></tt> は <tt class="xref docutils literal"><span class="pre">None</span></tt> を返し
ます:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;some_other_key&#39;</span><span class="p">)</span>
<span class="go">None</span>

<span class="go"># Wait 30 seconds for &#39;my_key&#39; to expire...</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;my_key&#39;</span><span class="p">)</span>
<span class="go">None</span>
</pre></div>
<p>get() には <tt class="docutils literal"><span class="pre">default</span></tt> 引数を指定できます:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;my_key&#39;</span><span class="p">,</span> <span class="s">&#39;has_expired&#39;</span><span class="p">)</span>
<span class="go">&#39;has_expired&#39;</span>
</pre></div>
<div class="versionadded">
<span class="title">Django 1.0 で新たに登場しました.</span> </div>
<p>キーに使う値がまだキャッシュ辞書上に存在しない場合にのみ、 <tt class="docutils literal"><span class="pre">add()</span></tt> メソッ
ドを使ってください。 <tt class="docutils literal"><span class="pre">add()</span></tt> メソッドは、 <tt class="docutils literal"><span class="pre">set()</span></tt> と同じ引数をとります
が、指定したキーがすでに存在する場合には、キャッシュを更新しません:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;add_key&#39;</span><span class="p">,</span> <span class="s">&#39;Initial value&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;add_key&#39;</span><span class="p">,</span> <span class="s">&#39;New value&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;add_key&#39;</span><span class="p">)</span>
<span class="go">&#39;Initial value&#39;</span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">add()</span></tt> によってキャッシュにデータが保存されたどうかを知りたければ、戻り
値をチェックしてください。戻り値が <tt class="xref docutils literal"><span class="pre">True</span></tt> なら、保存されています。そうで
ないときは <tt class="xref docutils literal"><span class="pre">False</span></tt> を返します。</p>
<p>キャッシュを一度しかアクセスしない <tt class="docutils literal"><span class="pre">get_many()</span></tt> インタフェースもあります。
<tt class="docutils literal"><span class="pre">get_many()</span></tt> は指定した全てのキーのうち、キャッシュ内に実在する (そして期
限切れでない) ものの入った辞書を返します:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">get_many</span><span class="p">([</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">])</span>
<span class="go">{&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}</span>
</pre></div>
<p>最後に、明示的なキーの削除は <tt class="docutils literal"><span class="pre">delete()</span></tt> で行えます。これは特定のオブジェ
クトに対するキャッシュを消去する簡単な方法です:</p>
<div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
</pre></div>
<p>これだけです。キャッシュにはほとんど制限がありません: 安全に pickle 化でき
るオブジェクトならなんでもキャッシュできます。ただし、キーは文字列でなけれ
ばなりません。</p>
</div>
<div class="section" id="s-id10">
<span id="s-upstream-caches"></span><h2>上流キャッシュ<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<p>ここまでは、 <em>自分の</em> データに対するキャッシュについて説明してきました。し
かし、 Web 開発にはもう一つのタイプのキャッシュが関係も関係してきます。それ
は 「上流 (upstream)」のキャッシュ機構で行われているキャッシュです。上流の
キャッシュは、ユーザのリクエストが Web サイトに到達する前ですらページのキャッ
シュを行います。</p>
<p>上流キャッシュの例をいくつか示します:</p>
<ul class="simple">
<li>ISP が特定のページをキャッシュしている場合、 somedomain.com のページ
をリクエストしても、 ISP はキャッシュページを返し、 somedomain.com に
アクセスしないかもしれません。</li>
<li>ページをキャッシュしてパフォーマンスを向上させるために、 Django Web
サイトを Squid Web プロキシ (<a class="reference external" href="http://www.squid-cache.org/">http://www.squid-cache.org/</a>) の背後に置
けます。この場合、リクエストはまず Squid でさばかれ、必要な時にのみア
プリケーションに渡されるようになります。</li>
<li>Web ブラウザもページをキャッシュします。 Web ページが適切なヘッダを送
信すると、ブラウザは以後の同じページへのリクエストにはローカルの (キャッ
シュされた) コピーを使うようになります。</li>
</ul>
<p>上流のキャッシュは効率を高める良い方法ではありますが、危険もはらんでいます:
多くの Web ページのコンテンツは認証に応じて異なる内容になります。また、その
他の変数も入ります。キャッシュシステムが純粋に URL だけに基づいてページを
盲目的に保存してしまうと、同じページを後から見た訪問者に対して正しくない情
報や機密の情報を晒してしまいます。</p>
<p>例えば、 Web ベースの e-mail システムを操作しているとしましょう。&quot;inbox&quot;
ページのコンテンツはいうまでもなくログインしているユーザ固有のものです。
ある ISP が盲目的にサイトをキャッシュしてしまうと、その ISP を経由して最初
にログインしたユーザは自分の inbox ページをキャッシュしてしまい、以降に
そのサイトを訪れたユーザが閲覧できるようになってしまいます。これはよろしく
ありません。</p>
<p>幸運にも、 HTTP にはこうした問題に対する解決策があります。すなわち、キャッ
シュ機構に指定の変数に基づいてコンテンツのキャッシュを行うよう指示したり、
キャッシュメカニズムが特定のページをキャッシュしないように指示したりする
一連の HTTP ヘッダがあるのです。</p>
</div>
<div class="section" id="s-vary">
<span id="s-using-vary-headers"></span><h2>Vary ヘッダを使う<a class="headerlink" href="#vary" title="Permalink to this headline">¶</a></h2>
<p>こうしたヘッダの一つに <tt class="docutils literal"><span class="pre">Vary</span></tt> があります。 <tt class="docutils literal"><span class="pre">Vary</span></tt> ヘッダは、キャッシュ
機構がキャッシュキーを生成するときに、どのリクエストヘッダを考慮すべきかを
定義しています。例えば、 Web ページのコンテンツが言語設定に依存している場合、
ページは「言語によって変化 (vary)」します。</p>
<p>デフォルトでは、 Django のキャッシュシステムはキャッシュキーをリクエストの
パス部分、例えば <tt class="docutils literal"><span class="pre">&quot;/stories/2005/jun/23/bank_robbed/&quot;</span></tt> を使って生成します。
これでは、クッキーや言語設定のようなユーザエージェント間の違いにかかわらず、
同じ URL を指すリクエストは全て同じバージョンのキャッシュを使うことになって
しまいます。</p>
<p>そこで <tt class="docutils literal"><span class="pre">Vary</span></tt> が登場します。</p>
<p>Django 下のページが、クッキーや言語、ユーザエージェントといったリクエストヘッ
ダ上の違いに基づいて、違った内容を出力する場合、 <tt class="docutils literal"><span class="pre">Vary</span></tt> ヘッダを使って、
ページ出力が何に依存しているかをキャッシュメカニズムに教える必要があります。</p>
<p>Django でこれを行うには、以下のような便宜用のビュー関数デコレータ、
<tt class="docutils literal"><span class="pre">vary_on_headers</span></tt> を使います:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.views.decorators.vary</span> <span class="kn">import</span> <span class="n">vary_on_headers</span>

<span class="c"># Python 2.3 syntax.</span>
<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
<span class="n">my_view</span> <span class="o">=</span> <span class="n">vary_on_headers</span><span class="p">(</span><span class="n">my_view</span><span class="p">,</span> <span class="s">&#39;User-Agent&#39;</span><span class="p">)</span>

<span class="c"># Python 2.4 decorator syntax.</span>
<span class="nd">@vary_on_headers</span><span class="p">(</span><span class="s">&#39;User-Agent&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
<p>上の場合では、 (Django 自体のキャッシュミドルウェアのような) キャッシュメカ
ニズムは個々のユーザエージェント固有の別のバージョンをキャッシュします。</p>
<p><tt class="docutils literal"><span class="pre">Vary</span></tt> ヘッダを (<tt class="docutils literal"><span class="pre">response['Vary']</span> <span class="pre">=</span> <span class="pre">'user-agent'</span></tt> のような操作で) 手動
で変更せずに、 <tt class="docutils literal"><span class="pre">vary_on_headers</span></tt> デコレータを使う利点は、デコレータが (す
でに存在するかもしれない) <tt class="docutils literal"><span class="pre">Vary</span></tt> ヘッダをスクラッチから作るのではなく、き
ちんと追加処理を行う点にあります。</p>
<p><tt class="docutils literal"><span class="pre">vary_on_headers()</span></tt> には複数のヘッダを渡せます:</p>
<div class="highlight"><pre><span class="nd">@vary_on_headers</span><span class="p">(</span><span class="s">&#39;User-Agent&#39;</span><span class="p">,</span> <span class="s">&#39;Cookie&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
<p>クッキーによるコンテンツの変更はよくあることなので、  <tt class="docutils literal"><span class="pre">vary_on_cookie</span></tt>
デコレータも用意されています。従って、以下の二つのビューは同じ振舞いをします:</p>
<div class="highlight"><pre><span class="nd">@vary_on_cookie</span>
<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>

<span class="nd">@vary_on_headers</span><span class="p">(</span><span class="s">&#39;Cookie&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">vary_on_headers</span></tt> に渡すヘッダは大小文字を区別しないので注意してください。
<tt class="docutils literal"><span class="pre">&quot;User-Agent&quot;</span></tt> は <tt class="docutils literal"><span class="pre">&quot;user-agent&quot;</span></tt> と同じです。</p>
<p>ヘルパー関数 <tt class="docutils literal"><span class="pre">django.utils.cache.patch_vary_headers()</span></tt> も直接使えます:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.utils.cache</span> <span class="kn">import</span> <span class="n">patch_vary_headers</span>
<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">render_to_response</span><span class="p">(</span><span class="s">&#39;template_name&#39;</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
    <span class="n">patch_vary_headers</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;Cookie&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">response</span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">patch_vary_headers</span></tt> は第一引数に <tt class="docutils literal"><span class="pre">HttpResponse</span></tt> インスタンスをとり、ヘッ
ダ名のリストまたはタプルを第二引数にとります。</p>
<p>Vary ヘッダの詳細は <a class="reference external" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.44">公式の Vary の仕様</a> を参照してください。</p>
</div>
<div class="section" id="s-id12">
<span id="s-controlling-cache-using-other-headers"></span><h2>Vary ヘッダ以外のヘッダを使ったキャッシュ制御<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<p>キャッシュの利用で起きるもう一つの問題は、データのプライバシーと、カスケー
ド接続したキャッシュのどこにデータを保存すべきかという疑問です。</p>
<p>通常、ユーザの目に触れるのは二種類のキャッシュ、すなわち自分のブラウザのキャッ
シュ (プライベートのキャッシュ) と、ページプロバイダ側のキャッシュ (公開の
キャッシュ) です。公開のキャッシュは複数のユーザによって利用されており、別
のユーザがその内容を制御することもあります。これは、注意の必要なデータを扱
う際には問題になります: 例えば、銀行のアカウント番号を公開キャッシュに保存
して欲しくはないでしょう。つまり、 Web アプリケーションにはどのデータがプラ
イベートで、どのデータが公開なのかを区別する方法が必要なのです。</p>
<p>この問題の解決策は、ページキャッシュが「プライベート」であると示すことです。
Django では、 <tt class="docutils literal"><span class="pre">cache_control</span></tt> ビューデコレータを使ってこれを実現します。
例えば:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.views.decorators.cache</span> <span class="kn">import</span> <span class="n">cache_control</span>
<span class="nd">@cache_control</span><span class="p">(</span><span class="n">private</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
<p>このデコレータは、適切な HTTP ヘッダが送信されるように背後で気を配ります。</p>
<p>他にもキャッシュパラメタを操作する方法がいくつかあります。例えば、 HTTP を
使うアプリケーションは以下のような操作を行えます:</p>
<ul class="simple">
<li>ページの最大キャッシュ回数を定義できます。</li>
<li>キャッシュされているコンテンツの新たなバージョンがないか常に調べ、変
更がないときに限ってキャッシュを送信するように設定できます (キャッシュ
によっては、サーバ上のページが変更されていても、単にキャッシュコピー
の有効期限が切れていないという理由でキャッシュされた内容を配信するこ
とがあります)。</li>
</ul>
<p>Django では、ビュー関数デコレータの <tt class="docutils literal"><span class="pre">cache_control</span></tt> を使って、キャッシュ
パラメタを設定します。以下の例では、 <tt class="docutils literal"><span class="pre">cache_control</span></tt> を使って、アクセス
ごとにコンテンツの再検証を行い、キャッシュされたバージョンの最大保存期限を
3600 秒に設定しています:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.views.decorators.cache</span> <span class="kn">import</span> <span class="n">cache_control</span>
<span class="nd">@cache_control</span><span class="p">(</span><span class="n">must_revalidate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">max_age</span><span class="o">=</span><span class="mi">3600</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">my_view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
<p>有効な <tt class="docutils literal"><span class="pre">Cache-Control</span></tt> HTTP ディレクティブは全て <tt class="docutils literal"><span class="pre">cache_control()</span></tt> に
使えます。利用できるディレクティブを示します:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">public=True</span></tt></li>
<li><tt class="docutils literal"><span class="pre">private=True</span></tt></li>
<li><tt class="docutils literal"><span class="pre">no_cache=True</span></tt></li>
<li><tt class="docutils literal"><span class="pre">no_transform=True</span></tt></li>
<li><tt class="docutils literal"><span class="pre">must_revalidate=True</span></tt></li>
<li><tt class="docutils literal"><span class="pre">proxy_revalidate=True</span></tt></li>
<li><tt class="docutils literal"><span class="pre">max_age=num_seconds</span></tt></li>
<li><tt class="docutils literal"><span class="pre">s_maxage=num_seconds</span></tt></li>
</ul>
<p>Cache-Control HTTP ディレクティブの説明は <a class="reference external" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">Cache-Control の仕様</a> を参照し
てください。</p>
<p>(キャッシュミドルウェアは常にキャッシュヘッダの最長寿命 (max-age) を
<tt class="docutils literal"><span class="pre">CACHE_MIDDLEWARE_SETTINGS</span></tt> の設定値に設定するので注意してください。カス
タムの <tt class="docutils literal"><span class="pre">max_age</span></tt> を <tt class="docutils literal"><span class="pre">cache_control</span></tt> デコレータで使うと、デコレータの設
定が優先され、ヘッダの値は正しくマージされます。)</p>
<p>ヘッダを使ってキャッシュを抑制したい場合には、
<tt class="docutils literal"><span class="pre">django.views.decorators.cache.never_cache</span></tt> を使ってください。このデコレー
タは、応答コンテンツがブラウザやその他のキャッシュ機構によってキャッシュさ
れないようにヘッダを追加します:</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">django.views.decorators.cache</span> <span class="kn">import</span> <span class="n">never_cache</span>
<span class="nd">@never_cache</span>
<span class="k">def</span> <span class="nf">myview</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<div class="section" id="s-id13">
<span id="s-other-optimizations"></span><h2>その他の最適化<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<p>Django には、アプリケーションのパフォーマンスを最適化する上で役立つミドルウェ
アが他にもいくつかあります:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">django.middleware.http.ConditionalGetMiddleware</span></tt> を使うと、条件付
き GET をサポートできるようになり、 <tt class="docutils literal"><span class="pre">ETag</span></tt> および <tt class="docutils literal"><span class="pre">Last-Modified</span></tt>
ヘッダを使えるようになります。</li>
<li><tt class="docutils literal"><span class="pre">django.middleware.gzip.GZipMiddleware</span></tt> は gzip 圧縮を扱えるブラウ
ザ (最近のほとんどのブラウザがそうです) に対して、コンテンツを gzip
で圧縮します。</li>
</ul>
</div>
<div class="section" id="s-middleware-classes">
<span id="s-order-of-middleware-classes"></span><h2>MIDDLEWARE_CLASSES の順番<a class="headerlink" href="#middleware-classes" title="Permalink to this headline">¶</a></h2>
<p>キャッシュ関連のミドルウェアを使う場合、 <tt class="docutils literal"><span class="pre">MIDDLEWARE_CLASSES</span></tt> 設定中の
正しい場所に配置することが重要です。というのも、キャッシュミドルウェアは
キャッシュストレージ上のコンテンツとの差異を検出するために、どのヘッダが変
更されたかを調べる必要があるからです。ミドルウェアは通常、必要に応じて
<tt class="docutils literal"><span class="pre">Vary</span></tt> レスポンスヘッダに情報を付加します。</p>
<p><tt class="docutils literal"><span class="pre">UpdateCacheMiddleware</span></tt> はレスポンスフェイズに動作します。レスポンスフェ
イズのミドルウェアは逆順に処理されるので、リストの先頭のミドルウェアは
<em>最後</em> に呼び出されます。従って、 <tt class="docutils literal"><span class="pre">UpdateCacheMiddleware</span></tt> は、 <tt class="docutils literal"><span class="pre">Vary</span></tt>
ヘッダに何らかの情報を付加するミドルウェアよりも <em>手前</em> に追加せねばなりま
せん。以下のミドルウェアが、 <tt class="docutils literal"><span class="pre">Vary</span></tt> ヘッダを操作します:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">SessionMiddleware</span></tt> は <tt class="docutils literal"><span class="pre">Cookie</span></tt> を追加します。</li>
<li><tt class="docutils literal"><span class="pre">GZipMiddleware</span></tt> は <tt class="docutils literal"><span class="pre">Accept-Encoding</span></tt> を追加します。</li>
<li><tt class="docutils literal"><span class="pre">LocaleMiddleware</span></tt> は <tt class="docutils literal"><span class="pre">Accept-Language</span></tt> を追加します。</li>
</ul>
<p>一方、 <tt class="docutils literal"><span class="pre">FetchFromCacheMiddleware</span></tt> はリクエストフェイズに動作します。リク
エストフェイズでは、ミドルウェアは先頭から末尾に向けて処理されるので、
リストの先頭にあるミドルウェアが <em>最初</em> に呼び出されます。
<tt class="docutils literal"><span class="pre">FetchFromCacheMiddleware</span></tt> もまた、 <tt class="docutils literal"><span class="pre">Vary</span></tt> ヘッダを操作するミドルウェア
よりも後に呼び出さねばならないので、 <tt class="docutils literal"><span class="pre">FetchFromCacheMiddleware</span></tt> は
<em>後ろ</em> に置かねばなりません。</p>
</div>
</div>


          </div>         
        </div>
      </div>
      
        
          <div class="yui-b" id="sidebar">
            
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3>Table Of Contents</h3>
            <ul>
<li><a class="reference external" href="">Django のキャッシュフレームワーク</a><ul>
<li><a class="reference external" href="#id1">キャッシュを立ち上げる</a><ul>
<li><a class="reference external" href="#memcached">memcached</a></li>
<li><a class="reference external" href="#id2">データベースを使ったキャッシュ</a></li>
<li><a class="reference external" href="#id3">ファイルシステムを使ったキャッシュ</a></li>
<li><a class="reference external" href="#id4">ローカルメモリ上のキャッシュ</a></li>
<li><a class="reference external" href="#id5">ダミーキャッシュ (開発用)</a></li>
<li><a class="reference external" href="#id6">カスタムのキャッシュバックエンドを使う</a></li>
<li><a class="reference external" href="#cache-backend">CACHE_BACKEND の引数</a></li>
</ul>
</li>
<li><a class="reference external" href="#id7">サイト単位のキャッシュ</a></li>
<li><a class="reference external" href="#id8">ビュー単位のキャッシュ</a></li>
<li><a class="reference external" href="#id9">テンプレートの部分的キャッシュ</a></li>
<li><a class="reference external" href="#api">低水準のキャッシュ API</a></li>
<li><a class="reference external" href="#id10">上流キャッシュ</a></li>
<li><a class="reference external" href="#vary">Vary ヘッダを使う</a></li>
<li><a class="reference external" href="#id12">Vary ヘッダ以外のヘッダを使ったキャッシュ制御</a></li>
<li><a class="reference external" href="#id13">その他の最適化</a></li>
<li><a class="reference external" href="#middleware-classes">MIDDLEWARE_CLASSES の順番</a></li>
</ul>
</li>
</ul>

  <h3>前後のページ</h3>
  <ul>
    
      <li>前: <a href="auth.html">Django でのユーザ認証</a></li>
    
    
      <li>次: <a href="email.html">電子メールの送信</a></li>
    
  </ul>
  <h3>現在のページ:</h3>
  <ul>
      <li>
        <a href="../index.html">Django v1.0 documentation</a>
        
          <ul><li><a href="index.html">Django を使う</a>
        
        <ul><li>Django のキャッシュフレームワーク</li></ul>
        </li></ul>
      </li>
  </ul>  

            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/topics/cache.txt">Show Source</a></li>
            </ul>
            <h3>Quick search</h3>
            <form class="search" action="../search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
      </div>
              <h3>Last update:</h3>
              <p class="topless">Aug 31, 2012</p>
          </div> 
        
      
    </div>
    
    <div id="ft">
      <div class="nav">
    &laquo; <a href="auth.html" title="Django でのユーザ認証">前へ</a> 
     |
    <a href="index.html" title="Django を使う" accesskey="U">上へ</a>
   |
    <a href="email.html" title="電子メールの送信">次へ</a> &raquo;</div>
    </div>
  </div>

      <div class="clearer"></div>
    </div>
  </body>
</html>